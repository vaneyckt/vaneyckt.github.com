<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mysql on vaneyckt.io</title>
    <link>http://vaneyckt.io/topics/mysql/</link>
    <description>Recent content in Mysql on vaneyckt.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Tom Van Eyck</copyright>
    <lastBuildDate>Thu, 20 Feb 2014 20:22:17 +0000</lastBuildDate>
    <atom:link href="http://vaneyckt.io/topics/mysql/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A visual explanation of SQL joins</title>
      <link>http://vaneyckt.io/posts/a_visual_explanation_of_sql_joins/</link>
      <pubDate>Thu, 20 Feb 2014 20:22:17 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/a_visual_explanation_of_sql_joins/</guid>
      <description>&lt;p&gt;I admit that I find myself going to &lt;a href=&#34;http://blog.codinghorror.com/a-visual-explanation-of-sql-joins/&#34;&gt;this article&lt;/a&gt; every time I need to write some joins. Hopefully putting it here will save me from always having to google it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why is MySQL converting my NULLs to blanks?</title>
      <link>http://vaneyckt.io/posts/why_is_mysql_converting_my_nulls_to_blanks/</link>
      <pubDate>Fri, 01 Nov 2013 19:17:56 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/why_is_mysql_converting_my_nulls_to_blanks/</guid>
      <description>&lt;p&gt;A while ago I ran into an issue where some records were showing a blank value in a given column. This was a bit weird as a blank value had never been written to that column. After a bit of searching we found that we had a bug that had inadvertently been writing the occasional NULL value to that particular column though. So how did those NULLs get turned into blanks?&lt;/p&gt;

&lt;p&gt;It turns out that MySQL can operate in different &lt;a href=&#34;https://dev.mysql.com/doc/refman/5.0/en/sql-mode.html&#34;&gt;server modes&lt;/a&gt;. You can check your server mode by running one of the two commands below. Note that your server mode will be blank by default.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;SHOW GLOBAL VARIABLES where Variable_name = &#39;sql_mode&#39;;
SHOW SESSION VARIABLES where Variable_name = &#39;sql_mode&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we know about server modes we can talk about &lt;a href=&#34;https://dev.mysql.com/doc/refman/5.0/en/data-type-defaults.html&#34;&gt;data type defaults&lt;/a&gt;. Basically, each MySQL column has an implicit default value assigned to it. Under certain circumstances this default value might be used instead of the value you were expecting.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;As of MySQL 5.0.2, if a column definition includes no explicit DEFAULT value, MySQL determines the default value as follows:&lt;/p&gt;

&lt;p&gt;If the column can take NULL as a value, the column is defined with an explicit DEFAULT NULL clause. This is the same as before 5.0.2.&lt;/p&gt;

&lt;p&gt;If the column cannot take NULL as the value, MySQL defines the column with no explicit DEFAULT clause. Exception: If the column is defined as part of a PRIMARY KEY but not explicitly as NOT NULL, MySQL creates it as a NOT NULL column (because PRIMARY KEY columns must be NOT NULL), but also assigns it a DEFAULT clause using the implicit default value. To prevent this, include an explicit NOT NULL in the definition of any PRIMARY KEY column.&lt;/p&gt;

&lt;p&gt;For data entry into a NOT NULL column that has no explicit DEFAULT clause, if an INSERT or REPLACE statement includes no value for the column, or an UPDATE statement sets the column to NULL, MySQL handles the column according to the SQL mode in effect at the time:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;If strict SQL mode is enabled, an error occurs for transactional tables and the statement is rolled back. For nontransactional tables, an error occurs, but if this happens for the second or subsequent row of a multiple-row statement, the preceding rows will have been inserted.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;If strict mode is not enabled, MySQL sets the column to the implicit default value for the column data type.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;We found that our code was sometimes writing NULLs to a NOT NULL column on a server that was not running in strict mode. This in turn caused our NULLs to silently get changed to blanks as this was the column default value. Mystery solved.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The paranoid approach to converting your MySQL database to utf8</title>
      <link>http://vaneyckt.io/posts/the_paranoid_approach_to_converting_your_mysql_database_to_utf8/</link>
      <pubDate>Sun, 20 Oct 2013 17:19:31 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/the_paranoid_approach_to_converting_your_mysql_database_to_utf8/</guid>
      <description>&lt;p&gt;Converting all the data in your database can be a nail-biting experience. As you can see from the code below we are doing our best to be super careful. We convert each table separately and before each conversion we store the table&amp;rsquo;s column types and an MD5 hash of every row in the table (we were lucky enough to not have enormous tables). After converting the table we check that no column types or rows were changed. It goes without saying that we do a trial run on a database dump first.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;set&#39;
require &#39;digest/md5&#39;

CHARACTER_SET = &#39;utf8&#39;
COLLATION = &#39;utf8_unicode_ci&#39;

class ConvertAllTablesToUtf8 &amp;lt; ActiveRecord::Migration
  def up
    ActiveRecord::Base.connection.tables.each do |table|
      ActiveRecord::Base.transaction do
        ActiveRecord::Base.connection.execute(&amp;quot;LOCK TABLES #{table} WRITE&amp;quot;)
          say &amp;quot;starting work on table: #{table}&amp;quot;

          model = table.classify.constantize
          say &amp;quot;associated model: #{model}&amp;quot;

          say &#39;storing column types information before converting table to unicode&#39;
          column_types_before = model.columns_hash.each_with_object({}) do |(column_name, column_info), column_types_before|
            column_types_before[column_name] = [column_info.sql_type, column_info.type]
          end

          say &#39;storing set of table data hashes before converting table to unicode&#39;
          table_data_before = Set.new
          model.find_each do |datum|
            table_data_before &amp;lt;&amp;lt; Digest::MD5.hexdigest(datum.inspect)
          end

          say &#39;converting table to unicode&#39;
          execute(&amp;quot;ALTER TABLE #{table} CONVERT TO CHARACTER SET #{CHARACTER_SET} COLLATE #{COLLATION}&amp;quot;)
          execute(&amp;quot;ALTER TABLE #{table} DEFAULT CHARACTER SET #{CHARACTER_SET} COLLATE #{COLLATION}&amp;quot;)

          say &#39;getting column types information after conversion to unicode&#39;
          column_types_after = model.columns_hash.each_with_object({}) do |(column_name, column_info), column_types_after|
            column_types_after[column_name] = [column_info.sql_type, column_info.type]
          end

          say &#39;getting set of table data hashes after conversion to unicode&#39;
          table_data_after = Set.new
          model.find_each do |datum|
            table_data_after &amp;lt;&amp;lt; Digest::MD5.hexdigest(datum.inspect)
          end

          say &amp;quot;checking that column types haven&#39;t changed&amp;quot;
          if column_types_before != column_types_after
            raise &amp;quot;Column types of the #{table} table have changed&amp;quot;
          end

          say &amp;quot;checking that data hasn&#39;t changed&amp;quot;
          if table_data_before != table_data_after
            raise &amp;quot;Data in the #{table} table has changed&amp;quot;
          end
        ActiveRecord::Base.connection.execute(&#39;UNLOCK TABLES&#39;)
      end
    end

    execute(&amp;quot;ALTER DATABASE #{ActiveRecord::Base.connection.current_database} DEFAULT CHARACTER SET #{CHARACTER_SET} COLLATE #{COLLATION}&amp;quot;)
  end

  def down
    raise ActiveRecord::IrreversibleMigration
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note how we lock each table before converting it. If we didn&amp;rsquo;t lock it then new data could be written to the table while we are busy storing MD5 hashes of the rows in preparation for the actual conversion. This, in turn, would cause our migration to complain that new data was present after the conversion had taken place.&lt;/p&gt;

&lt;p&gt;We also wrap each table conversion inside a transaction. I&amp;rsquo;ve talked before about &lt;a href=&#34;http://vaneyckt.io/posts/rails_migrations_and_the_dangers_of_implicit_commits/&#34;&gt;how converting a table will cause an implicit commit&lt;/a&gt;, meaning that a rollback won&amp;rsquo;t undo any of the changes made by the conversion. So why have a transaction here then? Imagine that an exception were to be raised during our migration. In that case we want to ensure our table lock gets dropped as soon as possible. The transaction guarantees this behavior.&lt;/p&gt;

&lt;p&gt;Also, if we weren&amp;rsquo;t so paranoid about checking the before and after data as part of our migration, we could simplify this code quite a bit.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;CHARACTER_SET = &#39;utf8&#39;
COLLATION = &#39;utf8_unicode_ci&#39;

class ConvertAllTablesToUtf8 &amp;lt; ActiveRecord::Migration
  def up
    ActiveRecord::Base.connection.tables.each do |table|
      say &#39;converting table to unicode&#39;
      execute(&amp;quot;ALTER TABLE #{table} CONVERT TO CHARACTER SET #{CHARACTER_SET} COLLATE #{COLLATION}&amp;quot;)
      execute(&amp;quot;ALTER TABLE #{table} DEFAULT CHARACTER SET #{CHARACTER_SET} COLLATE #{COLLATION}&amp;quot;)
    end

    execute(&amp;quot;ALTER DATABASE #{ActiveRecord::Base.connection.current_database} DEFAULT CHARACTER SET #{CHARACTER_SET} COLLATE #{COLLATION}&amp;quot;)
  end

  def down
    raise ActiveRecord::IrreversibleMigration
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how we can drop the lock as the &lt;code&gt;ALTER TABLE&lt;/code&gt; command &lt;a href=&#34;https://dev.mysql.com/doc/refman/5.1/en/alter-table.html&#34;&gt;will prevent all writes to the table while simultaneously allowing all reads&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In most cases, ALTER TABLE makes a temporary copy of the original table. MySQL waits for other operations that are modifying the table, then proceeds. It incorporates the alteration into the copy, deletes the original table, and renames the new one. While ALTER TABLE is executing, the original table is readable by other sessions. Updates and writes to the table that begin after the ALTER TABLE operation begins are stalled until the new table is ready, then are automatically redirected to the new table without any failed updates. The temporary copy of the original table is created in the database directory of the new table. This can differ from the database directory of the original table for ALTER TABLE operations that rename the table to a different database.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Furthermore, since we now no longer have a lock on our table we can also drop the transaction. This gives us the much-simplified code shown above.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Character set vs collation</title>
      <link>http://vaneyckt.io/posts/character_set_vs_collation/</link>
      <pubDate>Sat, 19 Oct 2013 20:31:43 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/character_set_vs_collation/</guid>
      <description>&lt;p&gt;There&amp;rsquo;s a surprising amount of confusion about the difference between these two terms. The best explanation I&amp;rsquo;ve found is &lt;a href=&#34;http://stackoverflow.com/questions/341273/what-does-character-set-and-collation-mean-exactly/341481#341481&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A character set is a subset of all written glyphs. A character encoding specifies how those characters are mapped to numeric values. Some character encodings, like UTF-8 and UTF-16, can encode any character in the Universal Character Set. Others, like US-ASCII or ISO-8859-1 can only encode a small subset, since they use 7 and 8 bits per character, respectively. Because many standards specify both a character set and a character encoding, the term &amp;ldquo;character set&amp;rdquo; is often substituted freely for &amp;ldquo;character encoding&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;A collation comprises rules that specify how characters can be compared for sorting. Collations rules can be locale-specific: the proper order of two characters varies from language to language.&lt;/p&gt;

&lt;p&gt;Choosing a character set and collation comes down to whether your application is internationalized or not. If not, what locale are you targeting?&lt;/p&gt;

&lt;p&gt;In order to choose what character set you want to support, you have to consider your application. If you are storing user-supplied input, it might be hard to foresee all the locales in which your software will eventually be used. To support them all, it might be best to support the UCS (Unicode) from the start. However, there is a cost to this; many western European characters will now require two bytes of storage per character instead of one.&lt;/p&gt;

&lt;p&gt;Choosing the right collation can help performance if your database uses the collation to create an index, and later uses that index to provide sorted results. However, since collation rules are often locale-specific, that index will be worthless if you need to sort results according to the rules of another locale.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The only thing I&amp;rsquo;d like to add is that some collations are more cpu intensive than others. For example, &lt;code&gt;utf8_general_ci&lt;/code&gt; treats À, Á, and Å as being equal to A when doing comparisons. This is in contrast to &lt;code&gt;utf8_unicode_ci&lt;/code&gt; which uses about 10% more cpu, but differentiates between these characters.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MySQL write locks also prevent reads</title>
      <link>http://vaneyckt.io/posts/mysql_write_locks_also_prevent_reads/</link>
      <pubDate>Thu, 17 Oct 2013 17:20:45 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/mysql_write_locks_also_prevent_reads/</guid>
      <description>&lt;p&gt;Locking a table with&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;table_name = &#39;widgets&#39;
ActiveRecord::Base.connection.execute(&amp;quot;LOCK TABLES #{table_name} WRITE&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ensures that &lt;a href=&#34;http://dev.mysql.com/doc/refman/5.0/en/lock-tables.html&#34;&gt;only the current connection can access that table&lt;/a&gt;. Other connections cannot even read from this table while it is locked!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rails migrations and the dangers of implicit commits</title>
      <link>http://vaneyckt.io/posts/rails_migrations_and_the_dangers_of_implicit_commits/</link>
      <pubDate>Wed, 16 Oct 2013 18:45:12 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/rails_migrations_and_the_dangers_of_implicit_commits/</guid>
      <description>&lt;p&gt;I recently came across the migration below. At first sight it looks like everything is okay, but there is actually a very dangerous assumption being made here.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# migration to convert table to utf8
class ConvertWidgetsTableToUtf8Unicode &amp;lt; ActiveRecord::Migration
  def up
    ActiveRecord::Base.transaction do
      table_name = &#39;widgets&#39;
      say &amp;quot;converting #{table_name} table to utf8_unicode_ci&amp;quot;

      execute(&amp;quot;ALTER TABLE #{table_name} CONVERT TO CHARACTER SET utf8 COLLATE utf8_unicode_ci&amp;quot;)
      execute(&amp;quot;ALTER TABLE #{table_name} DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci&amp;quot;)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how the utf8 conversion code is wrapped inside a transaction. The assumption here is that if something goes wrong the transaction will trigger a rollback. However, an &lt;code&gt;ALTER TABLE&lt;/code&gt; command in MySQL causes an &lt;a href=&#34;http://dev.mysql.com/doc/refman/5.0/en/implicit-commit.html&#34;&gt;implicit commit&lt;/a&gt;. This means that the rollback will not undo any changes introduced by the &lt;code&gt;ALTER TABLE&lt;/code&gt; command!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>