<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rails on vaneyckt.io</title>
    <link>http://vaneyckt.io/topics/rails/</link>
    <description>Recent content in Rails on vaneyckt.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Tom Van Eyck</copyright>
    <lastBuildDate>Thu, 09 Oct 2014 16:31:22 +0000</lastBuildDate>
    <atom:link href="http://vaneyckt.io/topics/rails/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Adding a post-execution hook to the db:migrate task</title>
      <link>http://vaneyckt.io/posts/adding_a_post_execution_hook_to_the_db_migrate_task/</link>
      <pubDate>Thu, 09 Oct 2014 16:31:22 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/adding_a_post_execution_hook_to_the_db_migrate_task/</guid>
      <description>&lt;p&gt;A few days ago we discovered that our MySQL database&amp;rsquo;s default character set and collation had been changed to the wrong values. Worse yet, it looked like this change had happened many months ago; something which we had been completely unaware of until now! In order to make sure this didn&amp;rsquo;t happen again, we looked into adding a post-execution hook to the rails db:migrate task.&lt;/p&gt;

&lt;p&gt;Our first attempt is shown below. Here, we append a post-execution hook to the existing db:migrate task by creating a new db:migrate task. In rake, when a task is defined twice, the behavior of the new task gets appended to the behavior of the old task. So even though the code below may give the impression of overwriting the rails db:migrate task, we are actually just appending a call to the &lt;code&gt;post_execution_hook&lt;/code&gt; method to it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;namespace :db do
  def post_execution_hook
    puts &#39;This code gets run after the rails db:migrate task.&#39;
    puts &#39;However, it only runs if the db:migrate task does not throw an exception.&#39;
  end

  task :migrate do
    post_execution_hook
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, the above example only runs the appended code if the original db:migrate task does not throw any exceptions. Luckily we can do better than that by taking a slightly different approach. Rather than appending code, we are going to have a go at prepending it instead.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;namespace :db do
  def post_execution_hook
    puts &#39;This code gets run after the rails db:migrate task.&#39;
    puts &#39;It will ALWAYS run.&#39;
  end

  task :attach_hook do
    at_exit { post_execution_hook }
  end
end

Rake::Task[&#39;db:migrate&#39;].enhance([&#39;db:attach_hook&#39;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we make use of the &lt;a href=&#34;http://ruby-doc.org/stdlib-2.0.0/libdoc/rake/rdoc/Rake/Task.html#method-i-enhance&#34;&gt;enhance method&lt;/a&gt; to add db:attach_hook as a prerequisite task to db:migrate. This means that calling db:migrate will now cause the db:attach_hook task to get executed before db:migrate gets run. The db:attach_hook task creates an &lt;code&gt;at_exit&lt;/code&gt; hook that will trigger our post-execution code upon exit of the db:migrate task. Hence, our post-execution hook will now get called even when db:migrate raises an exception!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Check the order of your rescue_from handlers!</title>
      <link>http://vaneyckt.io/posts/check_the_order_of_your_rescue_from_handlers/</link>
      <pubDate>Mon, 11 Nov 2013 21:34:16 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/check_the_order_of_your_rescue_from_handlers/</guid>
      <description>&lt;p&gt;Our &lt;code&gt;rescue_from&lt;/code&gt; handlers used to be defined like shown below. This might look okay to you. At first glance everything looks fine, right?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class WidgetsController &amp;lt; ActionController::Base
  rescue_from ActionController::RoutingError, :with =&amp;gt; :render_404
  rescue_from Exception,                      :with =&amp;gt; :render_500
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Turns out it&amp;rsquo;s not okay at all. Handlers are searched &lt;a href=&#34;http://apidock.com/rails/ActiveSupport/Rescuable/ClassMethods/rescue_from&#34;&gt;from bottom to top&lt;/a&gt;. This means that they should always be defined in order of most generic to most specific. Or in other words, the above code is exactly the wrong thing to do. Instead, we need to write our handlers like shown here.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class WidgetsController &amp;lt; ActionController::Base
  rescue_from Exception,                      :with =&amp;gt; :render_500
  rescue_from ActionController::RoutingError, :with =&amp;gt; :render_404
end
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Using environment variables in migrations</title>
      <link>http://vaneyckt.io/posts/using_environment_variables_in_migrations/</link>
      <pubDate>Tue, 29 Oct 2013 17:42:28 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/using_environment_variables_in_migrations/</guid>
      <description>&lt;p&gt;Recently we had to run a migration that was so slow we couldn&amp;rsquo;t afford the downtime it would cause. In order to get around this, it was decided to put two code paths in the migration: one that was slow and thorough, and one that was quick but didn&amp;rsquo;t perform any safety checks.&lt;/p&gt;

&lt;p&gt;The first path would be run on a recent database dump, whereas the latter would be executed directly on the live database once the first had finished without error. This was a lot less crazy than it might sound as the particular table under modification had very infrequent changes.&lt;/p&gt;

&lt;p&gt;It was decided to use environment variables to allow for easy switching between code paths. This is what the code ended up looking like.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyDangerousMigration &amp;lt; ActiveRecord::Migration
  def change
    if ENV[&#39;skip_checks&#39;] == &#39;true&#39;
      # code without safety checks
    else
      # code with safety checks
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This could then be run like so.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;skip_checks=true bundle exec rake db:migrate
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Carefully converting your MySQL database to utf8</title>
      <link>http://vaneyckt.io/posts/carefully_converting_your_mysql_database_to_utf8/</link>
      <pubDate>Sun, 20 Oct 2013 17:19:31 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/carefully_converting_your_mysql_database_to_utf8/</guid>
      <description>&lt;p&gt;Converting all the data in your database can be a nail-biting experience. As you can see from the code below we are doing our best to be super careful. We convert each table separately and before each conversion we store the table&amp;rsquo;s column types and an MD5 hash of every row in the table (we were lucky enough to not have enormous tables). After converting the table we check that no column types or rows were changed. It goes without saying that we do a trial run on a database dump first.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;set&#39;
require &#39;digest/md5&#39;

CHARACTER_SET = &#39;utf8&#39;
COLLATION = &#39;utf8_unicode_ci&#39;

class ConvertAllTablesToUtf8 &amp;lt; ActiveRecord::Migration
  def up
    ActiveRecord::Base.connection.tables.each do |table|
      ActiveRecord::Base.transaction do
        ActiveRecord::Base.connection.execute(&amp;quot;LOCK TABLES #{table} WRITE&amp;quot;)
          say &amp;quot;starting work on table: #{table}&amp;quot;

          model = table.classify.constantize
          say &amp;quot;associated model: #{model}&amp;quot;

          say &#39;storing column types information before converting table to unicode&#39;
          column_types_before = model.columns_hash.each_with_object({}) do |(column_name, column_info), column_types_before|
            column_types_before[column_name] = [column_info.sql_type, column_info.type]
          end

          say &#39;storing set of table data hashes before converting table to unicode&#39;
          table_data_before = Set.new
          model.find_each do |datum|
            table_data_before &amp;lt;&amp;lt; Digest::MD5.hexdigest(datum.inspect)
          end

          say &#39;converting table to unicode&#39;
          execute(&amp;quot;ALTER TABLE #{table} CONVERT TO CHARACTER SET #{CHARACTER_SET} COLLATE #{COLLATION}&amp;quot;)
          execute(&amp;quot;ALTER TABLE #{table} DEFAULT CHARACTER SET #{CHARACTER_SET} COLLATE #{COLLATION}&amp;quot;)

          say &#39;getting column types information after conversion to unicode&#39;
          column_types_after = model.columns_hash.each_with_object({}) do |(column_name, column_info), column_types_after|
            column_types_after[column_name] = [column_info.sql_type, column_info.type]
          end

          say &#39;getting set of table data hashes after conversion to unicode&#39;
          table_data_after = Set.new
          model.find_each do |datum|
            table_data_after &amp;lt;&amp;lt; Digest::MD5.hexdigest(datum.inspect)
          end

          say &amp;quot;checking that column types haven&#39;t changed&amp;quot;
          if column_types_before != column_types_after
            raise &amp;quot;Column types of the #{table} table have changed&amp;quot;
          end

          say &amp;quot;checking that data hasn&#39;t changed&amp;quot;
          if table_data_before != table_data_after
            raise &amp;quot;Data in the #{table} table has changed&amp;quot;
          end
        ActiveRecord::Base.connection.execute(&#39;UNLOCK TABLES&#39;)
      end
    end

    execute(&amp;quot;ALTER DATABASE #{ActiveRecord::Base.connection.current_database} DEFAULT CHARACTER SET #{CHARACTER_SET} COLLATE #{COLLATION}&amp;quot;)
  end

  def down
    raise ActiveRecord::IrreversibleMigration
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note how we lock each table before converting it. If we didn&amp;rsquo;t lock it then new data could be written to the table while we are busy storing MD5 hashes of the rows in preparation for the actual conversion. This, in turn, would cause our migration to complain that new data was present after the conversion had taken place.&lt;/p&gt;

&lt;p&gt;We also wrap each table conversion inside a transaction. I&amp;rsquo;ve talked before about &lt;a href=&#34;http://vaneyckt.io/posts/rails_migrations_and_the_dangers_of_implicit_commits/&#34;&gt;how converting a table will cause an implicit commit&lt;/a&gt;, meaning that a rollback won&amp;rsquo;t undo any of the changes made by the conversion. So why have a transaction here then? Imagine that an exception were to be raised during our migration. In that case we want to ensure our table lock gets dropped as soon as possible. The transaction guarantees this behavior.&lt;/p&gt;

&lt;p&gt;Also, if we weren&amp;rsquo;t so paranoid about checking the before and after data as part of our migration, we could simplify this code quite a bit.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;CHARACTER_SET = &#39;utf8&#39;
COLLATION = &#39;utf8_unicode_ci&#39;

class ConvertAllTablesToUtf8 &amp;lt; ActiveRecord::Migration
  def up
    ActiveRecord::Base.connection.tables.each do |table|
      say &#39;converting table to unicode&#39;
      execute(&amp;quot;ALTER TABLE #{table} CONVERT TO CHARACTER SET #{CHARACTER_SET} COLLATE #{COLLATION}&amp;quot;)
      execute(&amp;quot;ALTER TABLE #{table} DEFAULT CHARACTER SET #{CHARACTER_SET} COLLATE #{COLLATION}&amp;quot;)
    end

    execute(&amp;quot;ALTER DATABASE #{ActiveRecord::Base.connection.current_database} DEFAULT CHARACTER SET #{CHARACTER_SET} COLLATE #{COLLATION}&amp;quot;)
  end

  def down
    raise ActiveRecord::IrreversibleMigration
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how we can drop the lock as the &lt;code&gt;ALTER TABLE&lt;/code&gt; command &lt;a href=&#34;https://dev.mysql.com/doc/refman/5.1/en/alter-table.html&#34;&gt;will prevent all writes to the table while simultaneously allowing all reads&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In most cases, ALTER TABLE makes a temporary copy of the original table. MySQL waits for other operations that are modifying the table, then proceeds. It incorporates the alteration into the copy, deletes the original table, and renames the new one. While ALTER TABLE is executing, the original table is readable by other sessions. Updates and writes to the table that begin after the ALTER TABLE operation begins are stalled until the new table is ready, then are automatically redirected to the new table without any failed updates. The temporary copy of the original table is created in the database directory of the new table. This can differ from the database directory of the original table for ALTER TABLE operations that rename the table to a different database.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Furthermore, since we now no longer have a lock on our table we can also drop the transaction. This gives us the much-simplified code shown above.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MySQL write locks also prevent reads</title>
      <link>http://vaneyckt.io/posts/mysql_write_locks_also_prevent_reads/</link>
      <pubDate>Thu, 17 Oct 2013 17:20:45 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/mysql_write_locks_also_prevent_reads/</guid>
      <description>&lt;p&gt;Locking a table with&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;table_name = &#39;widgets&#39;
ActiveRecord::Base.connection.execute(&amp;quot;LOCK TABLES #{table_name} WRITE&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ensures that &lt;a href=&#34;http://dev.mysql.com/doc/refman/5.0/en/lock-tables.html&#34;&gt;only the current connection can access that table&lt;/a&gt;. Other connections cannot even read from this table while it is locked!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rails migrations and the dangers of implicit commits</title>
      <link>http://vaneyckt.io/posts/rails_migrations_and_the_dangers_of_implicit_commits/</link>
      <pubDate>Wed, 16 Oct 2013 18:45:12 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/rails_migrations_and_the_dangers_of_implicit_commits/</guid>
      <description>&lt;p&gt;I recently came across the migration below. At first sight it looks like everything is okay, but there is actually a very dangerous assumption being made here.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# migration to convert table to utf8
class ConvertWidgetsTableToUtf8Unicode &amp;lt; ActiveRecord::Migration
  def up
    ActiveRecord::Base.transaction do
      table_name = &#39;widgets&#39;
      say &amp;quot;converting #{table_name} table to utf8_unicode_ci&amp;quot;

      execute(&amp;quot;ALTER TABLE #{table_name} CONVERT TO CHARACTER SET utf8 COLLATE utf8_unicode_ci&amp;quot;)
      execute(&amp;quot;ALTER TABLE #{table_name} DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci&amp;quot;)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how the utf8 conversion code is wrapped inside a transaction. The assumption here is that if something goes wrong the transaction will trigger a rollback. However, an &lt;code&gt;ALTER TABLE&lt;/code&gt; command in MySQL causes an &lt;a href=&#34;http://dev.mysql.com/doc/refman/5.0/en/implicit-commit.html&#34;&gt;implicit commit&lt;/a&gt;. This means that the rollback will not undo any changes introduced by the &lt;code&gt;ALTER TABLE&lt;/code&gt; command!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>URI.js and URL manipulation in rails</title>
      <link>http://vaneyckt.io/posts/uri_js_and_url_manipulation_in_rails/</link>
      <pubDate>Sun, 13 Oct 2013 14:55:23 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/uri_js_and_url_manipulation_in_rails/</guid>
      <description>&lt;p&gt;Manipulating urls in javascript often ends up being an exercise in string interpolation. This rarely produces good looking code. Recently we&amp;rsquo;ve started enforcing the use of the &lt;a href=&#34;https://medialize.github.io/URI.js/&#34;&gt;URI.js library&lt;/a&gt; to combat this.&lt;/p&gt;

&lt;p&gt;Our new approach has us embed any necessary urls in hidden input fields on the web page in question. Rather than hardcoding these urls, we use the named route functionality offered by rails as this provides more flexibility. When the page gets rendered, these named routes are converted to actual urls through ERB templating. The embedded urls can then be fetched by javascript code and manipulated with URI.js.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s no silver bullet, but the resulting code is a lot more readable.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Finding models from strings with rails</title>
      <link>http://vaneyckt.io/posts/finding_models_from_strings_with_rails/</link>
      <pubDate>Fri, 11 Oct 2013 16:27:35 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/finding_models_from_strings_with_rails/</guid>
      <description>&lt;p&gt;Imagine you have a Widget model that stores data in a table &amp;lsquo;widgets&amp;rsquo;. At some point in your rails app you find yourself being given a string &amp;lsquo;Widget&amp;rsquo; and are asked to find the Widget model. This can be done like shown here.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;str = &#39;Widget&#39;
model = str.constantize
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, things get a bit harder when you have multiple Widget model subclasses (Widget::A, Widget::B), all of which are stored in the widgets table. This time around you&amp;rsquo;re given the string &amp;lsquo;Widget::A&amp;rsquo; and are asked to get the Widget model.&lt;/p&gt;

&lt;p&gt;In order to solve this we&amp;rsquo;ll need to ask the Widget::A model to give us its table name. If you&amp;rsquo;re following rails conventions you can then in turn use the table name to get the model you need.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;str = &#39;Widget&#39;
model = str.constantize.table_name.classify.constantize
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the above will only work if you&amp;rsquo;ve followed rails naming conventions though :).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Retrieving data in a time range with rails</title>
      <link>http://vaneyckt.io/posts/retrieving_data_in_a_time_range_with_rails/</link>
      <pubDate>Thu, 10 Oct 2013 19:22:45 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/retrieving_data_in_a_time_range_with_rails/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m writing this mostly as a reminder to myself, since I keep forgetting this :)&lt;/p&gt;

&lt;p&gt;Instead of:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;widgets = Widget.where(&amp;quot;? &amp;lt;= created_at AND created_at &amp;lt;= ?&amp;quot;, time_from, time_to)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;do this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;widgets = Widget.where(:created_at =&amp;gt; time_from .. time_to)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Profiling rails assets precompilation</title>
      <link>http://vaneyckt.io/posts/profiling_rails_assets_precompilation/</link>
      <pubDate>Sun, 01 Sep 2013 21:01:02 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/profiling_rails_assets_precompilation/</guid>
      <description>&lt;p&gt;Assets precompilation on rails can take a fair bit of time. This is especially annoying in scenarios where you want to deploy your app multiple times a day. Let&amp;rsquo;s see if we can come up with a way to actually figure out where all this time is being spent. Also, while I will be focusing on rails 3.2 in this post, the general principle should be easy enough to apply to other rails versions.&lt;/p&gt;

&lt;p&gt;Our first call of action is finding the assets precompilation logic. A bit of digging will turn up the &lt;a href=&#34;https://github.com/rails/rails/blob/3-2-stable/actionpack/lib/sprockets/assets.rake&#34;&gt;assets.rake file&lt;/a&gt; for rails 3.2. The relevant code starts on lines 59-67 and from there on out invokes methods throughout the entire file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# lines 59-67 of assets.rake
task :all do
  Rake::Task[&amp;quot;assets:precompile:primary&amp;quot;].invoke
  # We need to reinvoke in order to run the secondary digestless
  # asset compilation run - a fresh Sprockets environment is
  # required in order to compile digestless assets as the
  # environment has already cached the assets on the primary
  # run.
  if Rails.application.config.assets.digest
    ruby_rake_task(&amp;quot;assets:precompile:nondigest&amp;quot;, false)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we follow the calls made by the code above we can see that the actual compilation takes place on lines 50-56 of assets.rake and is done by the compile method of the &lt;a href=&#34;https://github.com/rails/rails/blob/3-2-stable/actionpack/lib/sprockets/static_compiler.rb&#34;&gt;Sprockets::StaticCompiler class&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# compile method of Sprockets::StaticCompiler class
def compile
  manifest = {}
  env.each_logical_path(paths) do |logical_path|
    if asset = env.find_asset(logical_path)
      digest_path = write_asset(asset)
      manifest[asset.logical_path] = digest_path
      manifest[aliased_path_for(asset.logical_path)] = digest_path
    end
  end
  write_manifest(manifest) if @manifest
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we know which code does the compiling, we can think of two ways to add some profiling to this. We could checkout the rails repo from Github, modify it locally and point our Gemfile to our modified local version of rails. Or, we could create a new rake task and monkey patch the compile method of the Sprockets::StaticCompiler class. We&amp;rsquo;ll go with the second option here as it is the more straightforward to implement.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll create a new rake file in the /lib/tasks folder of our rails app and name it &lt;code&gt;profile_assets_precompilation.rake&lt;/code&gt;. We then copy the contents of assets.rake into it, and wrap this code inside a new &amp;lsquo;profile&amp;rsquo; namespace so as to avoid conflicts. At the top of this file we&amp;rsquo;ll also add our monkey patched compile method so as to make it output profiling info. The resulting file should look like shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;namespace :profile do
  # monkey patch the compile method to output compilation times
  module Sprockets
    class StaticCompiler
      def compile
        manifest = {}
        env.each_logical_path(paths) do |logical_path|
          start_time = Time.now.to_f

          if asset = env.find_asset(logical_path)
            digest_path = write_asset(asset)
            manifest[asset.logical_path] = digest_path
            manifest[aliased_path_for(asset.logical_path)] = digest_path
          end

          # our profiling code
          duration = Time.now.to_f - start_time
          puts &amp;quot;#{logical_path} - #{duration.round(3)} seconds&amp;quot;
        end
        write_manifest(manifest) if @manifest
      end
    end
  end

  # contents of assets.rake
  namespace :assets do
    def ruby_rake_task(task, fork = true)
      env    = ENV[&#39;RAILS_ENV&#39;] || &#39;production&#39;
      groups = ENV[&#39;RAILS_GROUPS&#39;] || &#39;assets&#39;
      args   = [$0, task,&amp;quot;RAILS_ENV=#{env}&amp;quot;,&amp;quot;RAILS_GROUPS=#{groups}&amp;quot;]
      args &amp;lt;&amp;lt; &amp;quot;--trace&amp;quot; if Rake.application.options.trace
      if $0 =~ /rake\.bat\Z/i
        Kernel.exec $0, *args
      else
        fork ? ruby(*args) : Kernel.exec(FileUtils::RUBY, *args)
      end
    end

    # We are currently running with no explicit bundler group
    # and/or no explicit environment - we have to reinvoke rake to
    # execute this task.
    def invoke_or_reboot_rake_task(task)
      if ENV[&#39;RAILS_GROUPS&#39;].to_s.empty? || ENV[&#39;RAILS_ENV&#39;].to_s.empty?
        ruby_rake_task task
      else
        Rake::Task[task].invoke
      end
    end

    desc &amp;quot;Compile all the assets named in config.assets.precompile&amp;quot;
    task :precompile do
      invoke_or_reboot_rake_task &amp;quot;assets:precompile:all&amp;quot;
    end

    namespace :precompile do
      def internal_precompile(digest=nil)
        unless Rails.application.config.assets.enabled
          warn &amp;quot;Cannot precompile assets if sprockets is disabled. Please set config.assets.enabled to true&amp;quot;
          exit
        end

        # Ensure that action view is loaded and the appropriate
        # sprockets hooks get executed
        _ = ActionView::Base

        config = Rails.application.config
        config.assets.compile = true
        config.assets.digest  = digest unless digest.nil?
        config.assets.digests = {}

        env      = Rails.application.assets
        target   = File.join(Rails.public_path, config.assets.prefix)
        compiler = Sprockets::StaticCompiler.new(env,
                                                 target,
                                                 config.assets.precompile,
                                                 :manifest_path =&amp;gt; config.assets.manifest,
                                                 :digest =&amp;gt; config.assets.digest,
                                                 :manifest =&amp;gt; digest.nil?)
        compiler.compile
      end

      task :all do
        Rake::Task[&amp;quot;assets:precompile:primary&amp;quot;].invoke
        # We need to reinvoke in order to run the secondary digestless
        # asset compilation run - a fresh Sprockets environment is
        # required in order to compile digestless assets as the
        # environment has already cached the assets on the primary
        # run.
        ruby_rake_task(&amp;quot;assets:precompile:nondigest&amp;quot;, false) if Rails.application.config.assets.digest
      end

      task :primary =&amp;gt; [&amp;quot;assets:environment&amp;quot;, &amp;quot;tmp:cache:clear&amp;quot;] do
        internal_precompile
      end

      task :nondigest =&amp;gt; [&amp;quot;assets:environment&amp;quot;, &amp;quot;tmp:cache:clear&amp;quot;] do
        internal_precompile(false)
      end
    end

    desc &amp;quot;Remove compiled assets&amp;quot;
    task :clean do
      invoke_or_reboot_rake_task &amp;quot;assets:clean:all&amp;quot;
    end

    namespace :clean do
      task :all =&amp;gt; [&amp;quot;assets:environment&amp;quot;, &amp;quot;tmp:cache:clear&amp;quot;] do
        config = Rails.application.config
        public_asset_path = File.join(Rails.public_path, config.assets.prefix)
        rm_rf public_asset_path, :secure =&amp;gt; true
      end
    end

    task :environment do
      if Rails.application.config.assets.initialize_on_precompile
        Rake::Task[&amp;quot;environment&amp;quot;].invoke
      else
        Rails.application.initialize!(:assets)
        Sprockets::Bootstrap.new(Rails.application).run
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can run &lt;code&gt;bundle exec rake profile:assets:precompile&lt;/code&gt; to precompile our assets while outputting profiling info. Hopefully we can now finally figure out why this is always taking so long :).&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>