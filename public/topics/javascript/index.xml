<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on vaneyckt.io</title>
    <link>http://vaneyckt.io/topics/javascript/</link>
    <description>Recent content in Javascript on vaneyckt.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Tom Van Eyck</copyright>
    <lastBuildDate>Sat, 26 Sep 2015 17:54:23 +0000</lastBuildDate>
    <atom:link href="http://vaneyckt.io/topics/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A javascript closures recap</title>
      <link>http://vaneyckt.io/posts/a_javascript_closures_recap/</link>
      <pubDate>Sat, 26 Sep 2015 17:54:23 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/a_javascript_closures_recap/</guid>
      <description>

&lt;p&gt;Javascript closures have always been one those things that I used to navigate by intuition. Recently however, upon stumbling across some code that I did not quite grok, it became clear I should try and obtain a more formal understanding. This post is mainly intended as a quick recap for my future self. It won&amp;rsquo;t go into all the details about closures; instead it will focus on the bits that I found most helpful.&lt;/p&gt;

&lt;p&gt;There seem to be very few step-by-step overviews of javascript closures. As a matter of fact, I only found two. Luckily they are both absolute gems. You can find them &lt;a href=&#34;http://openhome.cc/eGossip/JavaScript/Closures.html&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://web.archive.org/web/20080209105120/http://blog.morrisjohns.com/javascript_closures_for_dummies&#34;&gt;here&lt;/a&gt;. I heartily recommend both these articles to anyone wanting to gain a more complete understanding of closures.&lt;/p&gt;

&lt;h3 id=&#34;closure-basics:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Closure basics&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m going to shamelessly borrow a few lines from the &lt;a href=&#34;http://openhome.cc/eGossip/JavaScript/Closures.html&#34;&gt;first&lt;/a&gt; of the two articles linked above to illustrate the basic concept of a closure.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function doSome() {
  var x = 10;

  function f(y) {
    return x + y;
  }
  return f;
}

var foo = doSome();
foo(20); // returns 30
foo(30); // returns 40
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;In the above example, the function f creates a closure. If you just look at f, it seems that the variable x is not defined. Actually, x is caught from the enclosing function. A closure is a function which closes (or survives) variables of the enclosing function. In the above example, the function f creates a closure because it closes the variable x into the scope of itself. If the closure object, a Function instance, is still alive, the closed variable x keeps alive. It&amp;rsquo;s like that the scope of the variable x is extended.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is really all you need to know about closures: they refer to variables declared outside the scope of the function and by doing so keep these variables alive. Closure behavior can be entirely explained just by keeping these two things in mind.&lt;/p&gt;

&lt;h3 id=&#34;closures-and-primitive-data-types:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Closures and primitive data types&lt;/h3&gt;

&lt;p&gt;The rest of this post will go over some code examples to illustrate the behavior of closures for both primitive and object params. In this section, we&amp;rsquo;ll have a look at the behavior of a closure with a primitive data type param.&lt;/p&gt;

&lt;h4 id=&#34;example-1:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 1&lt;/h4&gt;

&lt;p&gt;The code below will be our starting point for studying closures. Be sure to take a good look at it, as all our examples will be a variation of this code. Throughout this post, we are going to try and understand closures by examining the values returned by the &lt;code&gt;foo()&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var prim = 1;

var foo = function(p) {
  var f = function() {
    return p;
  }
  return f;
}(prim);

foo();    // returns 1
prim = 3;
foo();    // returns 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the javascript runtime wants to resolve the value returned by &lt;code&gt;return p;&lt;/code&gt;, it finds that this p variable is the same as the p variable from &lt;code&gt;var foo = function(p) {&lt;/code&gt;. In other words, there is no direct link between the p from &lt;code&gt;return p;&lt;/code&gt; and the variable prim from &lt;code&gt;var prim = 1;&lt;/code&gt;. We see this is true because assigning a new value to prim does not cause the value returned by &lt;code&gt;foo();&lt;/code&gt; to change.&lt;/p&gt;

&lt;h4 id=&#34;example-2:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 2&lt;/h4&gt;

&lt;p&gt;Now let&amp;rsquo;s have a look at what happens when we make a small change to the previous code sample by adding the line &lt;code&gt;p = 2;&lt;/code&gt; to it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var prim = 1;

var foo = function(p) {
  var f = function() {
    return p;
  }
  p = 2;
  return f;
}(prim);

foo();    // returns 2
prim = 3;
foo();    // returns 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above is interesting in that it shows that the p variable from &lt;code&gt;return p;&lt;/code&gt; is indeed the same as the p variable from &lt;code&gt;var foo = function(p) {&lt;/code&gt;. Even though the variable f gets created at a time when p is set to 1, the act of setting p to 2 does indeed cause the value returned by &lt;code&gt;foo();&lt;/code&gt; to change. This is a great example of a closure keeping a closed variable alive.&lt;/p&gt;

&lt;h4 id=&#34;example-3:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 3&lt;/h4&gt;

&lt;p&gt;This sample shows code similar to the first, but this time we made the closure close over the prim variable.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var prim = 1;

var foo = function() {
  return prim;
}

foo();    // returns 1
prim = 3;
foo();    // returns 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here too we can make a similar deduction as we did for the previous samples. When the javascript runtime wants to resolve the value returned by &lt;code&gt;return prim;&lt;/code&gt;, it finds that this prim variable is the same as the prim variable from &lt;code&gt;var prim = 1;&lt;/code&gt;. This explains why setting prim to 3 causes the value returned by &lt;code&gt;foo();&lt;/code&gt; to change.&lt;/p&gt;

&lt;h3 id=&#34;closures-and-objects:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Closures and objects&lt;/h3&gt;

&lt;p&gt;In this section we&amp;rsquo;ll see what happens when we take our code samples and change the param from a primitive data type to an object.&lt;/p&gt;

&lt;h4 id=&#34;example-1-a:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 1.a&lt;/h4&gt;

&lt;p&gt;The code below is interesting because in the previous section we saw that a similar example using a primitive param had both calls to &lt;code&gt;foo()&lt;/code&gt; return the same value. So what&amp;rsquo;s different here? Let&amp;rsquo;s inspect how the runtime resolves the variables involved.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var obj = [&amp;quot;a&amp;quot;];

var foo = function(o) {
  var f = function() {
    return o.length;
  }
  return f;
}(obj);

foo();        // returns 1
obj[1] = &amp;quot;b&amp;quot;; // modifies the object pointed to by the obj var
obj[2] = &amp;quot;c&amp;quot;; // modifies the object pointed to by the obj var
foo();        // returns 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the runtime tries to resolve the variable o from &lt;code&gt;return o.length;&lt;/code&gt;, it finds that this variable o is the same as the variable o from &lt;code&gt;var foo = function(o) {&lt;/code&gt;. We saw this exact same thing in the previous section. Unlike the previous section, the variable o now contains a reference to an array object. This causes our closure to have a direct link to this array object, and thus any changes to it will get reflected in the output of &lt;code&gt;foo()&lt;/code&gt;. This explains why the second call to &lt;code&gt;foo()&lt;/code&gt; gives a different output than the first.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A good rule of thumb goes like this:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;if a closed variable contains a value, then the closure links to that variable&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;if a closed variable contains a reference to an object, then the closure links to that object, and will pick up on any changes made to it&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;example-1-b:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 1.b&lt;/h4&gt;

&lt;p&gt;Note that the closure will only pick up on changes made to the particular object that was present when the closure was created. Assigning a new object to the obj variable after the closure was created will have no effect. The code below illustrates this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var obj = [&amp;quot;a&amp;quot;];

var foo = function(o) {
  var f = function() {
    return o.length;
  }
  return f;
}(obj);

foo();                 // returns 1
obj = [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]; // assign a new array object to the obj variable
foo();                 // returns 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, this code is practically identical to the code from Example 1 of the previous section.&lt;/p&gt;

&lt;h4 id=&#34;example-2-1:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 2&lt;/h4&gt;

&lt;p&gt;We&amp;rsquo;ll now modify the previous code sample a bit. This time we&amp;rsquo;ll take a look at what happens when we add the line &lt;code&gt;o[1] = &amp;quot;b&amp;quot;;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var obj = [&amp;quot;a&amp;quot;];

var foo = function(o) {
  var f = function() {
    return o.length;
  }
  o[1] = &amp;quot;b&amp;quot;;
  return f;
}(obj);

foo();        // returns 2
obj[1] = &amp;quot;b&amp;quot;;
obj[2] = &amp;quot;c&amp;quot;;
foo();        // returns 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once again, we can start by reasoning about how the runtime resolves the variable o from &lt;code&gt;return o.length;&lt;/code&gt;. As you probably know by now, this variable o is the same as the variable o from &lt;code&gt;var foo = function(o) {&lt;/code&gt;. And since it contains a reference to an object, any changes to this object will get reflected in the output of &lt;code&gt;foo()&lt;/code&gt;. This explains why the first call to &lt;code&gt;foo()&lt;/code&gt; now returns 2, whereas previously it was returning 1.&lt;/p&gt;

&lt;h4 id=&#34;example-3-1:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 3&lt;/h4&gt;

&lt;p&gt;If you managed to make it this far, this last bit of code should hold no surprises for you.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var obj = [&amp;quot;a&amp;quot;];

var foo = function() {
  return obj.length;
}

foo();        // returns 1
obj[1] = &amp;quot;b&amp;quot;;
obj[2] = &amp;quot;c&amp;quot;;
foo();        // returns 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The runtime will resolve the variable obj from &lt;code&gt;return obj.length;&lt;/code&gt; to be the same as the variable obj from &lt;code&gt;var obj = [&amp;quot;a&amp;quot;];&lt;/code&gt;. As a result, any changes to the obj variable will have an effect on the output of &lt;code&gt;foo()&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Hopefully this post has demystified closures a bit. Time and time again, we&amp;rsquo;ve shown how following a few simple steps will lead you to understand their behavior. Just keep in mind these rules of thumb and you should be good to go:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;if a closed variable contains a value, then the closure links to that variable&lt;/li&gt;
&lt;li&gt;if a closed variable contains a reference to an object, then the closure links to that object, and will pick up on any changes made to it&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ideally, this is going to become my go-to post for providing an introduction to closures. So please let me know any suggestions you might have to improve this post.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The javascript event loop</title>
      <link>http://vaneyckt.io/posts/the_javascript_event_loop/</link>
      <pubDate>Sun, 10 Nov 2013 20:50:04 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/the_javascript_event_loop/</guid>
      <description>&lt;p&gt;Sometimes you come across an article that is so well written you can&amp;rsquo;t do anything but link to it. So if you&amp;rsquo;ve ever wondered why the javascript runtime is so good at asynchronous operations, then you should definitely give &lt;a href=&#34;http://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/&#34;&gt;this article&lt;/a&gt; a read.&lt;/p&gt;

&lt;p&gt;Some snippets:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;JavaScript runtimes contain a message queue which stores a list of messages to be processed and their associated callback functions. These messages are queued in response to external events (such as a mouse being clicked or receiving the response to an HTTP request) given a callback function has been provided. If, for example a user were to click a button and no callback function was provided – no message would have been enqueued.&lt;/p&gt;

&lt;p&gt;In a loop, the queue is polled for the next message (each poll referred to as a “tick”) and when a message is encountered, the callback for that message is executed.&lt;/p&gt;

&lt;p&gt;The calling of this callback function serves as the initial frame in the call stack, and due to JavaScript being single-threaded, further message polling and processing is halted pending the return of all calls on the stack.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As well as:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Using Web Workers enables you to offload an expensive operation to a separate thread of execution, freeing up the main thread to do other things. The worker includes a separate message queue, event loop, and memory space independent from the original thread that instantiated it. Communication between the worker and the main thread is done via message passing, which looks very much like the traditional, evented code-examples we’ve already seen.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>