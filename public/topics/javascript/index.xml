<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on vaneyckt.io</title>
    <link>http://vaneyckt.io/topics/javascript/</link>
    <description>Recent content in Javascript on vaneyckt.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Tom Van Eyck</copyright>
    <lastBuildDate>Sat, 26 Sep 2015 17:54:23 +0000</lastBuildDate>
    <atom:link href="http://vaneyckt.io/topics/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A javascript closures recap</title>
      <link>http://vaneyckt.io/posts/a_javascript_closures_recap/</link>
      <pubDate>Sat, 26 Sep 2015 17:54:23 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/a_javascript_closures_recap/</guid>
      <description>

&lt;p&gt;Javascript closures have always been one those things that I used to navigate by intuition. Recently however, upon stumbling across some code that I did not quite grok, it became clear I should try and obtain a more formal understanding. This post is mainly intended as a quick recap for my future self. It won&amp;rsquo;t go into all the details about closures; instead it will focus on the bits that I found most helpful.&lt;/p&gt;

&lt;p&gt;There seem to be very few step-by-step overviews of javascript closures. As a matter of fact, I only found two. Luckily they are both absolute gems. You can find them &lt;a href=&#34;http://openhome.cc/eGossip/JavaScript/Closures.html&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://web.archive.org/web/20080209105120/http://blog.morrisjohns.com/javascript_closures_for_dummies&#34;&gt;here&lt;/a&gt;. I heartily recommend both these articles to anyone wanting to gain a more complete understanding of closures.&lt;/p&gt;

&lt;h3 id=&#34;closure-basics:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Closure basics&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m going to shamelessly borrow a few lines from the &lt;a href=&#34;http://openhome.cc/eGossip/JavaScript/Closures.html&#34;&gt;first&lt;/a&gt; of the two articles linked above to illustrate the basic concept of a closure.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function doSome() {
  var x = 10;

  function f(y) {
    return x + y;
  }
  return f;
}

var foo = doSome();
foo(20); // returns 30
foo(30); // returns 40
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;In the above example, the function f creates a closure. If you just look at f, it seems that the variable x is not defined. Actually, x is caught from the enclosing function. A closure is a function which closes (or survives) variables of the enclosing function. In the above example, the function f creates a closure because it closes the variable x into the scope of itself. If the closure object, a Function instance, is still alive, the closed variable x keeps alive. It&amp;rsquo;s like that the scope of the variable x is extended.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is really all you need to know about closures: they refer to variables declared outside the scope of the function and by doing so keep these variables alive. Closure behavior can be entirely explained just by keeping these two things in mind.&lt;/p&gt;

&lt;h3 id=&#34;closures-and-primitive-data-types:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Closures and primitive data types&lt;/h3&gt;

&lt;p&gt;The rest of this post will go over some code examples to illustrate the behavior of closures for both primitive and object params. In this section, we&amp;rsquo;ll have a look at the behavior of a closure with a primitive data type param.&lt;/p&gt;

&lt;h4 id=&#34;example-1:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 1&lt;/h4&gt;

&lt;p&gt;The code below will be our starting point for studying closures. Be sure to take a good look at it, as all our examples will be a variation of this code. Throughout this post, we are going to try and understand closures by examining the values returned by the &lt;code&gt;foo()&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var prim = 1;

var foo = function(p) {
  var f = function() {
    return p;
  }
  return f;
}(prim);

foo();    // returns 1
prim = 3;
foo();    // returns 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the javascript runtime wants to resolve the value returned by &lt;code&gt;return p;&lt;/code&gt;, it finds that this p variable is the same as the p variable from &lt;code&gt;var foo = function(p) {&lt;/code&gt;. In other words, there is no direct link between the p from &lt;code&gt;return p;&lt;/code&gt; and the variable prim from &lt;code&gt;var prim = 1;&lt;/code&gt;. We see this is true because assigning a new value to prim does not cause the value returned by &lt;code&gt;foo()&lt;/code&gt; to change.&lt;/p&gt;

&lt;h4 id=&#34;example-2:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 2&lt;/h4&gt;

&lt;p&gt;Now let&amp;rsquo;s have a look at what happens when we make a small change to the previous code sample by adding the line &lt;code&gt;p = 2;&lt;/code&gt; to it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var prim = 1;

var foo = function(p) {
  var f = function() {
    return p;
  }
  p = 2;
  return f;
}(prim);

foo();    // returns 2
prim = 3;
foo();    // returns 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above is interesting in that it shows that the p variable from &lt;code&gt;return p;&lt;/code&gt; is indeed the same as the p variable from &lt;code&gt;var foo = function(p) {&lt;/code&gt;. Even though the variable f gets created at a time when p is set to 1, the act of setting p to 2 does indeed cause the value returned by &lt;code&gt;foo()&lt;/code&gt; to change. This is a great example of a closure keeping a closed variable alive.&lt;/p&gt;

&lt;h4 id=&#34;example-3:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 3&lt;/h4&gt;

&lt;p&gt;This sample shows code similar to the first, but this time we made the closure close over the prim variable.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var prim = 1;

var foo = function() {
  return prim;
}

foo();    // returns 1
prim = 3;
foo();    // returns 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here too we can make a similar deduction as we did for the previous samples. When the javascript runtime wants to resolve the value returned by &lt;code&gt;return prim;&lt;/code&gt;, it finds that this prim variable is the same as the prim variable from &lt;code&gt;var prim = 1;&lt;/code&gt;. This explains why setting prim to 3 causes the value returned by &lt;code&gt;foo()&lt;/code&gt; to change.&lt;/p&gt;

&lt;h3 id=&#34;closures-and-objects:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Closures and objects&lt;/h3&gt;

&lt;p&gt;In this section we&amp;rsquo;ll see what happens when we take our code samples and change the param from a primitive data type to an object.&lt;/p&gt;

&lt;h4 id=&#34;example-1-a:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 1.a&lt;/h4&gt;

&lt;p&gt;The code below is interesting because in the previous section we saw that a similar example using a primitive param had both calls to &lt;code&gt;foo()&lt;/code&gt; return the same value. So what&amp;rsquo;s different here? Let&amp;rsquo;s inspect how the runtime resolves the variables involved.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var obj = [&amp;quot;a&amp;quot;];

var foo = function(o) {
  var f = function() {
    return o.length;
  }
  return f;
}(obj);

foo();        // returns 1
obj[1] = &amp;quot;b&amp;quot;; // modifies the object pointed to by the obj var
obj[2] = &amp;quot;c&amp;quot;; // modifies the object pointed to by the obj var
foo();        // returns 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the runtime tries to resolve the variable o from &lt;code&gt;return o.length;&lt;/code&gt;, it finds that this variable o is the same as the variable o from &lt;code&gt;var foo = function(o) {&lt;/code&gt;. We saw this exact same thing in the previous section. Unlike the previous section, the variable o now contains a reference to an array object. This causes our closure to have a direct link to this array object, and thus any changes to it will get reflected in the output of &lt;code&gt;foo()&lt;/code&gt;. This explains why the second call to &lt;code&gt;foo()&lt;/code&gt; gives a different output than the first.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A good rule of thumb goes like this:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;if a closed variable contains a value, then the closure links to that variable&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;if a closed variable contains a reference to an object, then the closure links to that object, and will pick up on any changes made to it&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;example-1-b:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 1.b&lt;/h4&gt;

&lt;p&gt;Note that the closure will only pick up on changes made to the particular object that was present when the closure was created. Assigning a new object to the obj variable after the closure was created will have no effect. The code below illustrates this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var obj = [&amp;quot;a&amp;quot;];

var foo = function(o) {
  var f = function() {
    return o.length;
  }
  return f;
}(obj);

foo();                 // returns 1
obj = [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]; // assign a new array object to the obj variable
foo();                 // returns 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, this code is practically identical to the code from Example 1 of the previous section.&lt;/p&gt;

&lt;h4 id=&#34;example-2-1:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 2&lt;/h4&gt;

&lt;p&gt;We&amp;rsquo;ll now modify the previous code sample a bit. This time we&amp;rsquo;ll take a look at what happens when we add the line &lt;code&gt;o[1] = &amp;quot;b&amp;quot;;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var obj = [&amp;quot;a&amp;quot;];

var foo = function(o) {
  var f = function() {
    return o.length;
  }
  o[1] = &amp;quot;b&amp;quot;;
  return f;
}(obj);

foo();        // returns 2
obj[1] = &amp;quot;b&amp;quot;;
obj[2] = &amp;quot;c&amp;quot;;
foo();        // returns 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once again, we can start by reasoning about how the runtime resolves the variable o from &lt;code&gt;return o.length;&lt;/code&gt;. As you probably know by now, this variable o is the same as the variable o from &lt;code&gt;var foo = function(o) {&lt;/code&gt;. And since it contains a reference to an object, any changes to this object will get reflected in the output of &lt;code&gt;foo()&lt;/code&gt;. This explains why the first call to &lt;code&gt;foo()&lt;/code&gt; now returns 2, whereas previously it was returning 1.&lt;/p&gt;

&lt;h4 id=&#34;example-3-1:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 3&lt;/h4&gt;

&lt;p&gt;If you managed to make it this far, this last bit of code should hold no surprises for you.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var obj = [&amp;quot;a&amp;quot;];

var foo = function() {
  return obj.length;
}

foo();        // returns 1
obj[1] = &amp;quot;b&amp;quot;;
obj[2] = &amp;quot;c&amp;quot;;
foo();        // returns 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The runtime will resolve the variable obj from &lt;code&gt;return obj.length;&lt;/code&gt; to be the same as the variable obj from &lt;code&gt;var obj = [&amp;quot;a&amp;quot;];&lt;/code&gt;. As a result, any changes to the obj variable will have an effect on the output of &lt;code&gt;foo()&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Hopefully this post has demystified closures a bit. Time and time again, we&amp;rsquo;ve shown how following a few simple steps will lead you to understand their behavior. Just keep in mind these rules of thumb and you should be good to go:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;if a closed variable contains a value, then the closure links to that variable&lt;/li&gt;
&lt;li&gt;if a closed variable contains a reference to an object, then the closure links to that object, and will pick up on any changes made to it&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ideally, this is going to become my go-to post for providing an introduction to closures. So please let me know any suggestions you might have to improve this post.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An introduction to javascript promises</title>
      <link>http://vaneyckt.io/posts/an_introduction_to_javascript_promises/</link>
      <pubDate>Sat, 07 Feb 2015 18:34:09 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/an_introduction_to_javascript_promises/</guid>
      <description>

&lt;p&gt;I recently had to write some javascript code that required the sequential execution of half a dozen asynchronous requests. I figured this was the perfect time to learn a bit more about javascript promises. This post is a recap of what I read in these &lt;a href=&#34;http://www.html5rocks.com/en/tutorials/es6/promises/&#34;&gt;three&lt;/a&gt; &lt;a href=&#34;http://www.mullie.eu/how-javascript-promises-work/&#34;&gt;amazing&lt;/a&gt; &lt;a href=&#34;http://www.sitepoint.com/overview-javascript-promises/&#34;&gt;write-ups&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;what-are-promises:e45390df332d7d109b53a5ac1df46eec&#34;&gt;What are promises?&lt;/h3&gt;

&lt;p&gt;A Promise object represents a value that may not be available yet, but will be resolved at some point in future. This abstraction allows you to write asynchronous code in a more synchronous fashion. For example, you can use a Promise object to represent data that will eventually be returned by a call to a remote web service. The &lt;code&gt;then&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; methods can be used to attach callbacks that will be triggered once the data arrives. We&amp;rsquo;ll take a closer look at these two methods in the next sections. For now, let&amp;rsquo;s write a simple AJAX request example that prints a random joke.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var promise = new Promise(function(resolve, reject) {
  $.ajax({
    url: &amp;quot;http://api.icndb.com/jokes/random&amp;quot;,
    success: function(result) {
      resolve(result[&amp;quot;value&amp;quot;][&amp;quot;joke&amp;quot;]);
    }
  });
});

promise.then(function(result) {
  console.log(result);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note how the Promise object is just a wrapper around the AJAX request and how we&amp;rsquo;ve instructed the &lt;code&gt;success&lt;/code&gt; callback to trigger the &lt;code&gt;resolve&lt;/code&gt; method. We&amp;rsquo;ve also attached a callback to our Promise object with the &lt;code&gt;then&lt;/code&gt; method. This callback gets triggered when the &lt;code&gt;resolve&lt;/code&gt; method gets called. The &lt;code&gt;result&lt;/code&gt; variable of this callback will contain the data that was passed to the &lt;code&gt;resolve&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;Before we take a closer look at the &lt;code&gt;resolve&lt;/code&gt; method, let&amp;rsquo;s first investigate the Promise object a bit more. A Promise object can have one of three states:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;fulfilled&lt;/strong&gt; - the action relating to the Promise succeeded&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rejected&lt;/strong&gt; - the action relating to the Promise failed&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pending&lt;/strong&gt; - the Promise hasn&amp;rsquo;t been fulfilled or rejected yet&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A pending Promise object can be fulfilled or rejected by calling &lt;code&gt;resolve&lt;/code&gt; or &lt;code&gt;reject&lt;/code&gt; on it. Once a Promise is fulfilled or rejected, this state gets permanently associated with it. The state of a fulfilled Promise also includes the data that was passed to &lt;code&gt;resolve&lt;/code&gt;, just as the state of a rejected Promise also includes the data that was passed to &lt;code&gt;reject&lt;/code&gt;. In summary, we can say that a Promise executes only once and stores the result of its execution.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var promise = new Promise(function(resolve, reject) {
  $.ajax({
    url: &amp;quot;http://api.icndb.com/jokes/random&amp;quot;,
    success: function(result) {
      resolve(result[&amp;quot;value&amp;quot;][&amp;quot;joke&amp;quot;]);
    }
  });
});

promise.then(function(result) {
  console.log(result);
});

promise.then(function(result) {
  console.log(result);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can test whether a Promise only ever executes once by adding a second callback to the previous example. In this case, we see that only one AJAX request gets made and that the same joke gets printed to the console twice. This clearly shows that our Promise was only executed once.&lt;/p&gt;

&lt;h3 id=&#34;the-then-method-and-chaining:e45390df332d7d109b53a5ac1df46eec&#34;&gt;The &lt;code&gt;then&lt;/code&gt; method and chaining&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;then&lt;/code&gt; method takes two arguments: a mandatory success callback and an optional failure callback. These callbacks are called when the Promise is settled (i.e. either fulfilled or rejected). If the Promise was fulfilled, the success callback will be fired with the data you passed to &lt;code&gt;resolve&lt;/code&gt;. If the Promise was rejected, the failure callback will be called with the data you passed to &lt;code&gt;reject&lt;/code&gt;. We&amp;rsquo;ve already covered most of this in the previous section.&lt;/p&gt;

&lt;p&gt;The real magic with the &lt;code&gt;then&lt;/code&gt; method happens when you start chaining several of them together. This chaining allows you to express your logic in separate stages, each of which can be made responsible for transforming data passed on by the previous stage or for running additional asynchronous requests. The code below shows how data returned by the success callback of the first &lt;code&gt;then&lt;/code&gt; method becomes available to the success callback of the second &lt;code&gt;then&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var promise = new Promise(function(resolve, reject) {
  $.ajax({
    url: &amp;quot;http://api.icndb.com/jokes/random&amp;quot;,
    success: function(result) {
      resolve(result[&amp;quot;value&amp;quot;][&amp;quot;joke&amp;quot;]);
    }
  });
});

promise.then(function(result) {
  return result;
}).then(function(result) {
  console.log(result);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This chaining is possible because the &lt;code&gt;then&lt;/code&gt; method returns a new Promise object that will resolve to the return value of the callback. Or in other words, by calling &lt;code&gt;return result;&lt;/code&gt; we cause the creation of an anonymous Promise object that looks something like shown below. Notice that this particular anonymous Promise object will resolve immediately, as it does not make any asynchronous requests.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;new Promise(function(resolve, reject) {
  resolve(result);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we understand that the &lt;code&gt;then&lt;/code&gt; method always returns a Promise object, let&amp;rsquo;s take a look at what happens when we tell the callback of a &lt;code&gt;then&lt;/code&gt; method to explicitly return a Promise object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function getJokePromise() {
  return new Promise(function(resolve, reject) {
    $.ajax({
      url: &amp;quot;http://api.icndb.com/jokes/random&amp;quot;,
      success: function(result) {
        resolve(result[&amp;quot;value&amp;quot;][&amp;quot;joke&amp;quot;]);
      }
    });
  });
}

getJokePromise().then(function(result) {
  console.log(result);
  return getJokePromise();
}).then(function(result) {
  console.log(result);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, we end up sequentially executing two asynchronous requests. When the first Promise is resolved, the first joke is printed and a new Promise object is returned by the &lt;code&gt;then&lt;/code&gt; method. This new Promise object then has &lt;code&gt;then&lt;/code&gt; called on it. When the Promise succeeds, the &lt;code&gt;then&lt;/code&gt; success callback is triggered and the second joke is printed.&lt;/p&gt;

&lt;p&gt;The takeaway from all this is that calling &lt;code&gt;return&lt;/code&gt; in a &lt;code&gt;then&lt;/code&gt; callback will always result in returning a Promise object. It is this that allows for &lt;code&gt;then&lt;/code&gt; chaining!&lt;/p&gt;

&lt;h3 id=&#34;error-handling:e45390df332d7d109b53a5ac1df46eec&#34;&gt;Error handling&lt;/h3&gt;

&lt;p&gt;We mentioned in the previous section how the &lt;code&gt;then&lt;/code&gt; method can take an optional failure callback that gets triggered when &lt;code&gt;reject&lt;/code&gt; is called. It is customary to reject with an Error object as they capture a stack trace, thereby facilitating debugging.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var promise = new Promise(function(resolve, reject) {
  $.ajax({
    url: &amp;quot;http://random.url.com&amp;quot;,
    success: function(result) {
      resolve(result[&amp;quot;value&amp;quot;][&amp;quot;joke&amp;quot;]);
    },
    error: function(jqxhr, textStatus) {
      reject(Error(&amp;quot;The AJAX request failed.&amp;quot;));
    }
  });
});

promise.then(function(result) {
  console.log(result);
}, function(error) {
  console.log(error);
  console.log(error.stack);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Personally, I find this a bit hard to read. Luckily we can use the &lt;code&gt;catch&lt;/code&gt; method to make this look a bit nicer. There&amp;rsquo;s nothing special about the &lt;code&gt;catch&lt;/code&gt; method. In fact, it&amp;rsquo;s just sugar for &lt;code&gt;then(undefined, func)&lt;/code&gt;, but it definitely makes code easier to read.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var promise = new Promise(function(resolve, reject) {
  $.ajax({
    url: &amp;quot;http://random.url.com&amp;quot;,
    success: function(result) {
      resolve(result[&amp;quot;value&amp;quot;][&amp;quot;joke&amp;quot;]);
    },
    error: function(jqxhr, textStatus) {
      reject(Error(&amp;quot;The AJAX request failed.&amp;quot;));
    }
  });
});

promise.then(function(result) {
  console.log(result);
}).then(function(result) {
  console.log(&amp;quot;foo&amp;quot;); // gets skipped
}).then(function(result) {
  console.log(&amp;quot;bar&amp;quot;); // gets skipped
}).catch(function(error) {
  console.log(error);
  console.log(error.stack);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aside from illustrating improved readability, the above code showcases another aspect of the &lt;code&gt;reject&lt;/code&gt; method in that Promise rejections will cause your code to skip forward to the next &lt;code&gt;then&lt;/code&gt; method that has a rejection callback (or the next &lt;code&gt;catch&lt;/code&gt; method, since this is equivalent). It is this fallthrough behavior that causes this code to not print &amp;ldquo;foo&amp;rdquo; or &amp;ldquo;bar&amp;rdquo;!&lt;/p&gt;

&lt;p&gt;As a final point, it is useful to know that a Promise is implicitly rejected if an error is thrown in its constructor callback. This means it&amp;rsquo;s useful to do all your Promise related work inside the Promise constructor callback, so errors automatically become rejections.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var promise = new Promise(function(resolve, reject) {
  // JSON.parse throws an error if you feed it some
  // invalid JSON, so this implicitly rejects
  JSON.parse(&amp;quot;This ain&#39;t JSON&amp;quot;);
});

promise.then(function(result) {
  console.log(result);
}).catch(function(error) {
  console.log(error);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code will cause the Promise to be rejected and an error to be printed because it will fail to parse the invalid JSON string.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The javascript event loop</title>
      <link>http://vaneyckt.io/posts/the_javascript_event_loop/</link>
      <pubDate>Sun, 10 Nov 2013 20:50:04 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/the_javascript_event_loop/</guid>
      <description>&lt;p&gt;Sometimes you come across an article that is so well written you can&amp;rsquo;t do anything but link to it. So if you&amp;rsquo;ve ever wondered why the javascript runtime is so good at asynchronous operations, then you should definitely give &lt;a href=&#34;http://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/&#34;&gt;this article&lt;/a&gt; a read.&lt;/p&gt;

&lt;p&gt;Some snippets:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;JavaScript runtimes contain a message queue which stores a list of messages to be processed and their associated callback functions. These messages are queued in response to external events (such as a mouse being clicked or receiving the response to an HTTP request) given a callback function has been provided. If, for example a user were to click a button and no callback function was provided – no message would have been enqueued.&lt;/p&gt;

&lt;p&gt;In a loop, the queue is polled for the next message (each poll referred to as a “tick”) and when a message is encountered, the callback for that message is executed.&lt;/p&gt;

&lt;p&gt;The calling of this callback function serves as the initial frame in the call stack, and due to JavaScript being single-threaded, further message polling and processing is halted pending the return of all calls on the stack.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As well as:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Using Web Workers enables you to offload an expensive operation to a separate thread of execution, freeing up the main thread to do other things. The worker includes a separate message queue, event loop, and memory space independent from the original thread that instantiated it. Communication between the worker and the main thread is done via message passing, which looks very much like the traditional, evented code-examples we’ve already seen.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>