<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Git on vaneyckt.io</title>
    <link>http://vaneyckt.io/topics/git/</link>
    <description>Recent content in Git on vaneyckt.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Tom Van Eyck</copyright>
    <lastBuildDate>Sat, 08 Feb 2014 18:05:12 +0000</lastBuildDate>
    <atom:link href="http://vaneyckt.io/topics/git/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Some lesser known Github API functionality</title>
      <link>http://vaneyckt.io/posts/some_lesser_known_github_api_functionality/</link>
      <pubDate>Sat, 08 Feb 2014 18:05:12 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/some_lesser_known_github_api_functionality/</guid>
      <description>

&lt;p&gt;One of our automation tools occasionally needs to interact with our Github repositories. Unfortunately, the current implementation of this tool leaves something to be desired as it requires cloning these repositories to local disk. Changes against these local repositories are then made on local branches, after which these branches get pushed to Github.&lt;/p&gt;

&lt;p&gt;However, in order to save on disk space this tool will only ever create a single local copy of each repository. This makes it unsafe to run multiple instances of this tool as multiple instances simultaneously executing sequences of git commands against the same local repositories might lead to these commands inadvertently getting interpolated, thereby leaving the local repositories in an undefined state.&lt;/p&gt;

&lt;p&gt;The solution to this complexity was to completely remove the need for local repositories and instead aim to have everything done through the wonderful Github API. This article is a reminder to myself about some API functionality that I found while looking into this.&lt;/p&gt;

&lt;h3 id=&#34;checking-if-a-branch-contains-a-commit:ebeddf967e2b970d374ec29d22d794b8&#34;&gt;Checking if a branch contains a commit&lt;/h3&gt;

&lt;p&gt;While the Github API does not have an explicit call to check whether a given commit is included in a branch, we can nevertheless use the &lt;a href=&#34;https://developer.github.com/v3/repos/commits/#compare-two-commits&#34;&gt;compare call&lt;/a&gt; for just this purpose. This call takes two commits as input and returns a large JSON response of comparison data. We can use the &lt;code&gt;status&lt;/code&gt; field of the response to ascertain if a given commit is behind or identical to the HEAD commit of a branch. If so, then the branch contains that commit.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;octokit&#39;

class GithubClient &amp;lt; Octokit::Client
  def branch_contains_sha?(repo, branch, sha)
    [&#39;behind&#39;, &#39;identical&#39;].include?(compare(repo, branch, sha).status)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;creating-a-remote-branch-from-a-remote-commit:ebeddf967e2b970d374ec29d22d794b8&#34;&gt;Creating a remote branch from a remote commit&lt;/h3&gt;

&lt;p&gt;Sometimes you&amp;rsquo;ll want to create a remote branch by branching from a remote commit. We can use the &lt;a href=&#34;https://developer.github.com/v3/git/refs/#create-a-reference&#34;&gt;create_reference call&lt;/a&gt; to accomplish this. Note that the &lt;code&gt;ref&lt;/code&gt; parameter of this call needs to be set to &lt;code&gt;refs/heads/#{branch}&lt;/code&gt; when creating a remote branch.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;octokit&#39;

class GithubClient &amp;lt; Octokit::Client
  def create_branch_from_sha(repo, branch, sha)
    # create_ref internally transforms &amp;quot;heads/#{branch}&amp;quot; into &amp;quot;refs/heads/#{branch}&amp;quot;
    # as mentioned above, this is required by the Github API
    create_ref(repo, &amp;quot;heads/#{branch}&amp;quot;, sha)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;setting-the-head-of-a-remote-branch-to-a-specific-remote-commit:ebeddf967e2b970d374ec29d22d794b8&#34;&gt;Setting the HEAD of a remote branch to a specific remote commit&lt;/h3&gt;

&lt;p&gt;You can even forcefully set the HEAD of a remote branch to a specific remote commit by using the &lt;a href=&#34;https://developer.github.com/v3/git/refs/#update-a-reference&#34;&gt;update_reference call&lt;/a&gt;. As mentioned earlier, the &lt;code&gt;ref&lt;/code&gt; parameter needs to be set to &lt;code&gt;refs/heads/#{branch}&lt;/code&gt;. Be careful when using this functionality though as it essentially allows you to overwrite the history of a remote branch!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;octokit&#39;

class GithubClient &amp;lt; Octokit::Client
  def update_branch_to_sha(repo, branch, sha, force = true)
    # update_ref internally transforms &amp;quot;heads/#{branch}&amp;quot; into &amp;quot;refs/heads/#{branch}&amp;quot;
    # as mentioned earlier, this is required by the Github API
    update_ref(repo, &amp;quot;heads/#{branch}&amp;quot;, sha, force)
  end
end
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Bug hunting with git bisect</title>
      <link>http://vaneyckt.io/posts/bug_hunting_with_git_bisect/</link>
      <pubDate>Mon, 04 Nov 2013 20:02:14 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/bug_hunting_with_git_bisect/</guid>
      <description>&lt;p&gt;Today I was looking into what I thought was going to be a simple bug. The problem seemed straightforward enough, so I did a quick grep of the codebase, found three pieces of code that looked like likely culprits, made some modifications, triggered the bug, and found that absolutely nothing had changed. Half an hour and a lot of additional digging later I was stumped. I had no idea what was going on.&lt;/p&gt;

&lt;p&gt;It was at this point that I remembered &lt;code&gt;git bisect&lt;/code&gt;. This git command asks you to specify two commits: one where things are working, and another one where things are broken. It then does a binary search across the range of commits in between these two. Each search step asks you whether the current commit contains broken code or not, after which it automatically selects the next commit for you. There&amp;rsquo;s a great tutorial over &lt;a href=&#34;http://webchick.net/node/99&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git bisect start
$ git bisect good rj6y4j3
$ git bisect bad 2q7f529
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It took me all of five minutes to discover the source of the bug this way. I can safely say that it would have taken me ages to track down this particular bit of offending code as it was located in a custom bug fix for a popular third party library (I&amp;rsquo;m looking at you &lt;a href=&#34;https://github.com/getsentry/raven-ruby&#34;&gt;Sentry&lt;/a&gt;).&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>