<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on vaneyckt.io</title>
    <link>http://vaneyckt.io/posts/</link>
    <description>Recent content in Posts on vaneyckt.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Tom Van Eyck</copyright>
    <lastBuildDate>Sat, 19 Dec 2015 19:20:03 +0000</lastBuildDate>
    <atom:link href="http://vaneyckt.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>The disaster that is Ruby&#39;s timeout method</title>
      <link>http://vaneyckt.io/posts/the_disaster_that_is_rubys_timeout_method/</link>
      <pubDate>Sat, 19 Dec 2015 19:20:03 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/the_disaster_that_is_rubys_timeout_method/</guid>
      <description>

&lt;p&gt;On paper, &lt;a href=&#34;http://ruby-doc.org/stdlib-2.1.1/libdoc/timeout/rdoc/Timeout.html#method-c-timeout&#34;&gt;Ruby&amp;rsquo;s timeout method&lt;/a&gt; looks like an incredibly useful piece of code. Ever had a network request occasionally slow down your entire program because it just wouldn&amp;rsquo;t finish? That&amp;rsquo;s where &lt;code&gt;timeout&lt;/code&gt; comes in. It provides a hard guarantee that a block of code will be finished within a specified amount of time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;timeout&#39;

timeout(5) do
  # block of code that should be interrupted if it takes more than 5 seconds
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s one thing the documentation doesn&amp;rsquo;t tell you though. If any of the lines in that block of code introduces side effects that rely on the execution of later lines of code to leave things in a stable state, then using the &lt;code&gt;timeout&lt;/code&gt; method is a great way to introduce instability in your program. Examples of this include pretty much any program that is not entirely without stateful information. Let&amp;rsquo;s have a closer look at this method to try and figure out what&amp;rsquo;s going on here exactly.&lt;/p&gt;

&lt;h3 id=&#34;exceptions-absolutely-anywhere:9337c8a75f66f40fb43aecac823e1f80&#34;&gt;Exceptions absolutely anywhere&lt;/h3&gt;

&lt;p&gt;The problem with &lt;code&gt;timeout&lt;/code&gt; is that it relies upon Ruby&amp;rsquo;s questionable ability to have one thread raise an exception &lt;em&gt;absolutely anywhere&lt;/em&gt; in an entirely different thread. The idea is that when you place code inside a &lt;code&gt;timeout&lt;/code&gt; block, this code gets wrapped inside a new thread that executes in the background while the main thread goes to sleep for 5 seconds. Upon waking, the main thread grabs the background thread and forcefully stops it by raising a &lt;code&gt;Timeout::Error&lt;/code&gt; exception on it (&lt;a href=&#34;https://github.com/ruby/ruby/blob/trunk/lib/timeout.rb#L72-L110&#34;&gt;actual implementation&lt;/a&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# raising_exceptions.rb
# threads can raise exceptions in other threads
thr = Thread.new do
  puts &#39;...initializing resource&#39;
  sleep 1

  puts &#39;...using resource&#39;
  sleep 1

  puts &#39;...cleaning resource&#39;
  sleep 1
end

sleep 1.5
thr.raise(&#39;raising an exception in the thread&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ruby raising_exeptions.rb

...initializing resource
...using resource
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem with this approach is that the main thread does not care what code the background thread is executing when it raises the exception. This means that the engineer responsible for the code that gets executed by the background thread needs to assume an exception can get thrown from &lt;em&gt;absolutely anywhere&lt;/em&gt; within her code. This is madness! No one can be expected to place exception catchers around every single block of code!&lt;/p&gt;

&lt;p&gt;The following code further illustrates the problem of being able to raise an exception &lt;em&gt;absolutely anywhere&lt;/em&gt;. Turns out that &lt;em&gt;absolutely anywhere&lt;/em&gt; includes locations like the inside of &lt;code&gt;ensure&lt;/code&gt; blocks. These locations are generally not designed for handling any exceptions at all. I hope you weren&amp;rsquo;t using an &lt;code&gt;ensure&lt;/code&gt; block to terminate your database connection!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# ensure_block.rb
# raising exceptions inside an ensure block of another thread
# note how we never finish cleaning the resource here
thr = Thread.new do
  begin
    puts &#39;...initializing resource&#39;
    sleep 1

    raise &#39;something went wrong&#39;

    puts &#39;...using resource&#39;
    sleep 1
  ensure
    puts &#39;...started cleaning resource&#39;
    sleep 1
    puts &#39;...finished cleaning resource&#39;
  end
end

sleep 1.5
thr.raise(&#39;raising an exception in the thread&#39;)

# prevent program from immediately terminating after raising exception
sleep 5
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ruby ensure_blocks.rb

...initializing resource
...started cleaning resource
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;real-world-example:9337c8a75f66f40fb43aecac823e1f80&#34;&gt;Real world example&lt;/h3&gt;

&lt;p&gt;Recently, I spent a lot of time working with the &lt;a href=&#34;https://github.com/taf2/curb&#34;&gt;curb http client&lt;/a&gt;. I ended up wrapping quite a few of my curb calls within &lt;code&gt;timeout&lt;/code&gt; blocks because of tight time constraints. However, this caused great instability within the system I was working on. Sometimes a call would work, whereas other times that very same call would throw an exception about an invalid handle. It was this that caused me to start investigating the &lt;code&gt;timeout&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;After having a bit of think, I came up with a proof of concept that showed beyond a doubt that the &lt;code&gt;timeout&lt;/code&gt; method was introducing instability in the very internals of my http client. The finished proof of concept code can look a bit complex, so rather than showing the final concept code straightaway, I&amp;rsquo;ll run you through my thought process instead.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start with the basics and write some code that uses the http client to fetch a random google page. A randomized parameter is added to the google url in order to circumvent any client-side caching. The page fetch itself is wrapped inside a &lt;code&gt;timeout&lt;/code&gt; block as we are interested in testing whether the &lt;code&gt;timeout&lt;/code&gt; method is corrupting the http client.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# basics.rb
# timeout doesn&#39;t get triggered
require &#39;curb&#39;
require &#39;timeout&#39;

timeout(1) do
  Curl.get(&amp;quot;http://www.google.com?foo=#{rand}&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code will rarely timeout as a page fetch generally takes way less than one second to complete. This is why we&amp;rsquo;re going to wrap our page fetch inside an infinite while loop.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# infinite_loop.rb
# timeout gets triggered and Timeout::Error exception gets thrown
require &#39;curb&#39;
require &#39;timeout&#39;

timeout(1) do
  while true
    Curl.get(&amp;quot;http://www.google.com?foo=#{rand}&amp;quot;)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ruby infinite_loop.rb

/Users/vaneyckt/.rvm/gems/ruby-2.0.0-p594/gems/curb-0.8.8/lib/curl/easy.rb:68:
  in &#39;perform&#39;: execution expired (Timeout::Error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code is now timing out and throwing a &lt;code&gt;Timeout::Error&lt;/code&gt; exception. Next we want to determine whether the timing out of a page fetch could corrupt the internal state of the http client, thereby causing problems for a subsequent page fetch. We&amp;rsquo;ll need to make lots of page fetches to test this, so we&amp;rsquo;re going to wrap all of our current code inside another infinite while loop. Furthermore, we don&amp;rsquo;t want any &lt;code&gt;Timeout::Error&lt;/code&gt; exceptions to break us out of this while loop, so we&amp;rsquo;re going to catch and ignore these exceptions inside the while loop we just created. This gives us our finished proof of concept code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# proof_of_concept.rb
# timeout corrupts the very internals of the curb http client
require &#39;curb&#39;
require &#39;timeout&#39;

while true
  begin
    timeout(1) do
      while true
        Curl.get(&amp;quot;http://www.google.com?foo=#{rand}&amp;quot;)
      end
    end
  rescue Timeout::Error =&amp;gt; e
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ruby proof_of_concept.rb

/Users/vaneyckt/.rvm/gems/ruby-2.0.0-p594/gems/curb-0.8.8/lib/curl/easy.rb:67:
  in &#39;add&#39;: CURLError: The easy handle is already added to a multi handle
  (Curl::Err::MultiAddedAlready)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running the above program will result in an exception being thrown after a few seconds. At some point, the &lt;code&gt;timeout&lt;/code&gt; method is causing a &lt;code&gt;Timeout::Error&lt;/code&gt; exception to be raised inside a critical code path of the http client. This badly timed &lt;code&gt;Timeout::Error&lt;/code&gt; exception leaves the client in an invalid state, which in turn causes the next page fetch to fail with the exception shown above. Hopefully this illustrates why you should avoid creating programs that can have &lt;code&gt;Timeout::Error&lt;/code&gt; exceptions pop up &lt;em&gt;absolutely anywhere&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:9337c8a75f66f40fb43aecac823e1f80&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;I hope this has convinced you there is nothing you can do to prevent &lt;code&gt;timeout&lt;/code&gt; from doing whatever it wants to your program&amp;rsquo;s internal state. There is just no way a program can deal with &lt;code&gt;Timeout::Error&lt;/code&gt; exceptions being able to potentially pop up &lt;em&gt;absolutely anywhere&lt;/em&gt;. The only time you can really get away with using timeouts is when writing functional code that does not rely on any state. In all other cases, it is best to just avoid timeouts entirely.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A javascript closures recap</title>
      <link>http://vaneyckt.io/posts/a_javascript_closures_recap/</link>
      <pubDate>Sat, 26 Sep 2015 17:54:23 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/a_javascript_closures_recap/</guid>
      <description>

&lt;p&gt;Javascript closures have always been one those things that I used to navigate by intuition. Recently however, upon stumbling across some code that I did not quite grok, it became clear I should try and obtain a more formal understanding. This post is mainly intended as a quick recap for my future self. It won&amp;rsquo;t go into all the details about closures; instead it will focus on the bits that I found most helpful.&lt;/p&gt;

&lt;p&gt;There seem to be very few step-by-step overviews of javascript closures. As a matter of fact, I only found two. Luckily they are both absolute gems. You can find them &lt;a href=&#34;http://openhome.cc/eGossip/JavaScript/Closures.html&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://web.archive.org/web/20080209105120/http://blog.morrisjohns.com/javascript_closures_for_dummies&#34;&gt;here&lt;/a&gt;. I heartily recommend both these articles to anyone wanting to gain a more complete understanding of closures.&lt;/p&gt;

&lt;h3 id=&#34;closure-basics:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Closure basics&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m going to shamelessly borrow a few lines from the &lt;a href=&#34;http://openhome.cc/eGossip/JavaScript/Closures.html&#34;&gt;first&lt;/a&gt; of the two articles linked above to illustrate the basic concept of a closure.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function doSome() {
  var x = 10;

  function f(y) {
    return x + y;
  }
  return f;
}

var foo = doSome();
foo(20); // returns 30
foo(30); // returns 40
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;In the above example, the function f creates a closure. If you just look at f, it seems that the variable x is not defined. Actually, x is caught from the enclosing function. A closure is a function which closes (or survives) variables of the enclosing function. In the above example, the function f creates a closure because it closes the variable x into the scope of itself. If the closure object, a Function instance, is still alive, the closed variable x keeps alive. It&amp;rsquo;s like that the scope of the variable x is extended.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is really all you need to know about closures: they refer to variables declared outside the scope of the function and by doing so keep these variables alive. Closure behavior can be entirely explained just by keeping these two things in mind.&lt;/p&gt;

&lt;h3 id=&#34;closures-and-primitive-data-types:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Closures and primitive data types&lt;/h3&gt;

&lt;p&gt;The rest of this post will go over some code examples to illustrate the behavior of closures for both primitive and object params. In this section, we&amp;rsquo;ll have a look at the behavior of a closure with a primitive data type param.&lt;/p&gt;

&lt;h4 id=&#34;example-1:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 1&lt;/h4&gt;

&lt;p&gt;The code below will be our starting point for studying closures. Be sure to take a good look at it, as all our examples will be a variation of this code. Throughout this post, we are going to try and understand closures by examining the values returned by the &lt;code&gt;foo()&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var prim = 1;

var foo = function(p) {
  var f = function() {
    return p;
  }
  return f;
}(prim);

foo();    // returns 1
prim = 3;
foo();    // returns 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the javascript runtime wants to resolve the value returned by &lt;code&gt;return p;&lt;/code&gt;, it finds that this p variable is the same as the p variable from &lt;code&gt;var foo = function(p) {&lt;/code&gt;. In other words, there is no direct link between the p from &lt;code&gt;return p;&lt;/code&gt; and the variable prim from &lt;code&gt;var prim = 1;&lt;/code&gt;. We see this is true because assigning a new value to prim does not cause the value returned by &lt;code&gt;foo()&lt;/code&gt; to change.&lt;/p&gt;

&lt;h4 id=&#34;example-2:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 2&lt;/h4&gt;

&lt;p&gt;Now let&amp;rsquo;s have a look at what happens when we make a small change to the previous code sample by adding the line &lt;code&gt;p = 2;&lt;/code&gt; to it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var prim = 1;

var foo = function(p) {
  var f = function() {
    return p;
  }
  p = 2;
  return f;
}(prim);

foo();    // returns 2
prim = 3;
foo();    // returns 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above is interesting in that it shows that the p variable from &lt;code&gt;return p;&lt;/code&gt; is indeed the same as the p variable from &lt;code&gt;var foo = function(p) {&lt;/code&gt;. Even though the variable f gets created at a time when p is set to 1, the act of setting p to 2 does indeed cause the value returned by &lt;code&gt;foo()&lt;/code&gt; to change. This is a great example of a closure keeping a closed variable alive.&lt;/p&gt;

&lt;h4 id=&#34;example-3:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 3&lt;/h4&gt;

&lt;p&gt;This sample shows code similar to the first, but this time we made the closure close over the prim variable.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var prim = 1;

var foo = function() {
  return prim;
}

foo();    // returns 1
prim = 3;
foo();    // returns 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here too we can make a similar deduction as we did for the previous samples. When the javascript runtime wants to resolve the value returned by &lt;code&gt;return prim;&lt;/code&gt;, it finds that this prim variable is the same as the prim variable from &lt;code&gt;var prim = 1;&lt;/code&gt;. This explains why setting prim to 3 causes the value returned by &lt;code&gt;foo()&lt;/code&gt; to change.&lt;/p&gt;

&lt;h3 id=&#34;closures-and-objects:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Closures and objects&lt;/h3&gt;

&lt;p&gt;In this section we&amp;rsquo;ll see what happens when we take our code samples and change the param from a primitive data type to an object.&lt;/p&gt;

&lt;h4 id=&#34;example-1-a:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 1.a&lt;/h4&gt;

&lt;p&gt;The code below is interesting because in the previous section we saw that a similar example using a primitive param had both calls to &lt;code&gt;foo()&lt;/code&gt; return the same value. So what&amp;rsquo;s different here? Let&amp;rsquo;s inspect how the runtime resolves the variables involved.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var obj = [&amp;quot;a&amp;quot;];

var foo = function(o) {
  var f = function() {
    return o.length;
  }
  return f;
}(obj);

foo();        // returns 1
obj[1] = &amp;quot;b&amp;quot;; // modifies the object pointed to by the obj var
obj[2] = &amp;quot;c&amp;quot;; // modifies the object pointed to by the obj var
foo();        // returns 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the runtime tries to resolve the variable o from &lt;code&gt;return o.length;&lt;/code&gt;, it finds that this variable o is the same as the variable o from &lt;code&gt;var foo = function(o) {&lt;/code&gt;. We saw this exact same thing in the previous section. Unlike the previous section, the variable o now contains a reference to an array object. This causes our closure to have a direct link to this array object, and thus any changes to it will get reflected in the output of &lt;code&gt;foo()&lt;/code&gt;. This explains why the second call to &lt;code&gt;foo()&lt;/code&gt; gives a different output than the first.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A good rule of thumb goes like this:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;if a closed variable contains a value, then the closure links to that variable&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;if a closed variable contains a reference to an object, then the closure links to that object, and will pick up on any changes made to it&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;example-1-b:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 1.b&lt;/h4&gt;

&lt;p&gt;Note that the closure will only pick up on changes made to the particular object that was present when the closure was created. Assigning a new object to the obj variable after the closure was created will have no effect. The code below illustrates this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var obj = [&amp;quot;a&amp;quot;];

var foo = function(o) {
  var f = function() {
    return o.length;
  }
  return f;
}(obj);

foo();                 // returns 1
obj = [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]; // assign a new array object to the obj variable
foo();                 // returns 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, this code is practically identical to the code from Example 1 of the previous section.&lt;/p&gt;

&lt;h4 id=&#34;example-2-1:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 2&lt;/h4&gt;

&lt;p&gt;We&amp;rsquo;ll now modify the previous code sample a bit. This time we&amp;rsquo;ll take a look at what happens when we add the line &lt;code&gt;o[1] = &amp;quot;b&amp;quot;;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var obj = [&amp;quot;a&amp;quot;];

var foo = function(o) {
  var f = function() {
    return o.length;
  }
  o[1] = &amp;quot;b&amp;quot;;
  return f;
}(obj);

foo();        // returns 2
obj[1] = &amp;quot;b&amp;quot;;
obj[2] = &amp;quot;c&amp;quot;;
foo();        // returns 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once again, we can start by reasoning about how the runtime resolves the variable o from &lt;code&gt;return o.length;&lt;/code&gt;. As you probably know by now, this variable o is the same as the variable o from &lt;code&gt;var foo = function(o) {&lt;/code&gt;. And since it contains a reference to an object, any changes to this object will get reflected in the output of &lt;code&gt;foo()&lt;/code&gt;. This explains why the first call to &lt;code&gt;foo()&lt;/code&gt; now returns 2, whereas previously it was returning 1.&lt;/p&gt;

&lt;h4 id=&#34;example-3-1:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Example 3&lt;/h4&gt;

&lt;p&gt;If you managed to make it this far, this last bit of code should hold no surprises for you.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var obj = [&amp;quot;a&amp;quot;];

var foo = function() {
  return obj.length;
}

foo();        // returns 1
obj[1] = &amp;quot;b&amp;quot;;
obj[2] = &amp;quot;c&amp;quot;;
foo();        // returns 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The runtime will resolve the variable obj from &lt;code&gt;return obj.length;&lt;/code&gt; to be the same as the variable obj from &lt;code&gt;var obj = [&amp;quot;a&amp;quot;];&lt;/code&gt;. As a result, any changes to the obj variable will have an effect on the output of &lt;code&gt;foo()&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:fd3eb7d414a05af8a77db8210b1ff256&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Hopefully this post has demystified closures a bit. Time and time again, we&amp;rsquo;ve shown how following a few simple steps will lead you to understand their behavior. Just keep in mind these rules of thumb and you should be good to go:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;if a closed variable contains a value, then the closure links to that variable&lt;/li&gt;
&lt;li&gt;if a closed variable contains a reference to an object, then the closure links to that object, and will pick up on any changes made to it&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ideally, this is going to become my go-to post for providing an introduction to closures. So please let me know any suggestions you might have to improve this post.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Installing Chromedriver</title>
      <link>http://vaneyckt.io/posts/installing_chromedriver/</link>
      <pubDate>Sun, 16 Aug 2015 19:43:34 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/installing_chromedriver/</guid>
      <description>&lt;p&gt;Some time ago I needed to install &lt;a href=&#34;https://sites.google.com/a/chromium.org/chromedriver/&#34;&gt;chromedriver&lt;/a&gt; on a ubuntu machine. While this wasn&amp;rsquo;t too hard, I was nevertheless surprised by the number of open StackOverflow questions on this topic. So I decided to leave some notes for my future self.&lt;/p&gt;

&lt;p&gt;First of all, let&amp;rsquo;s install chromedriver.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ LATEST_RELEASE=$(curl http://chromedriver.storage.googleapis.com/LATEST_RELEASE)
$ wget http://chromedriver.storage.googleapis.com/$LATEST_RELEASE/chromedriver_linux64.zip
$ unzip chromedriver_linux64.zip
$ rm chromedriver_linux64.zip
$ sudo mv chromedriver /usr/local/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s see what happens when we try and run it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ chromedriver

chromedriver: error while loading shared libraries: libgconf-2.so.4:
cannot open shared object file: No such file or directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s a bit unexpected. Luckily we can easily fix this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo apt-get install libgconf-2-4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have a functioning chromedriver, the only thing left to do is to install Chrome. After all, chromedriver can&amp;rsquo;t function without Chrome.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add -
$ sudo sh -c &#39;echo &amp;quot;deb http://dl.google.com/linux/chrome/deb/ stable main&amp;quot; &amp;gt;&amp;gt; /etc/apt/sources.list.d/google.list&#39;
$ sudo apt-get update
$ sudo apt-get install google-chrome-stable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s it. You should be good to go now.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An introduction to javascript promises</title>
      <link>http://vaneyckt.io/posts/an_introduction_to_javascript_promises/</link>
      <pubDate>Sat, 07 Feb 2015 18:34:09 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/an_introduction_to_javascript_promises/</guid>
      <description>

&lt;p&gt;I recently had to write some javascript code that required the sequential execution of half a dozen asynchronous requests. I figured this was the perfect time to learn a bit more about javascript promises. This post is a recap of what I read in these &lt;a href=&#34;http://www.html5rocks.com/en/tutorials/es6/promises/&#34;&gt;three&lt;/a&gt; &lt;a href=&#34;http://www.mullie.eu/how-javascript-promises-work/&#34;&gt;amazing&lt;/a&gt; &lt;a href=&#34;http://www.sitepoint.com/overview-javascript-promises/&#34;&gt;write-ups&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;what-are-promises:e45390df332d7d109b53a5ac1df46eec&#34;&gt;What are promises?&lt;/h3&gt;

&lt;p&gt;A Promise object represents a value that may not be available yet, but will be resolved at some point in future. This abstraction allows you to write asynchronous code in a more synchronous fashion. For example, you can use a Promise object to represent data that will eventually be returned by a call to a remote web service. The &lt;code&gt;then&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; methods can be used to attach callbacks that will be triggered once the data arrives. We&amp;rsquo;ll take a closer look at these two methods in the next sections. For now, let&amp;rsquo;s write a simple AJAX request example that prints a random joke.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var promise = new Promise(function(resolve, reject) {
  $.ajax({
    url: &amp;quot;http://api.icndb.com/jokes/random&amp;quot;,
    success: function(result) {
      resolve(result[&amp;quot;value&amp;quot;][&amp;quot;joke&amp;quot;]);
    }
  });
});

promise.then(function(result) {
  console.log(result);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note how the Promise object is just a wrapper around the AJAX request and how we&amp;rsquo;ve instructed the &lt;code&gt;success&lt;/code&gt; callback to trigger the &lt;code&gt;resolve&lt;/code&gt; method. We&amp;rsquo;ve also attached a callback to our Promise object with the &lt;code&gt;then&lt;/code&gt; method. This callback gets triggered when the &lt;code&gt;resolve&lt;/code&gt; method gets called. The &lt;code&gt;result&lt;/code&gt; variable of this callback will contain the data that was passed to the &lt;code&gt;resolve&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;Before we take a closer look at the &lt;code&gt;resolve&lt;/code&gt; method, let&amp;rsquo;s first investigate the Promise object a bit more. A Promise object can have one of three states:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;fulfilled&lt;/strong&gt; - the action relating to the Promise succeeded&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rejected&lt;/strong&gt; - the action relating to the Promise failed&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pending&lt;/strong&gt; - the Promise hasn&amp;rsquo;t been fulfilled or rejected yet&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A pending Promise object can be fulfilled or rejected by calling &lt;code&gt;resolve&lt;/code&gt; or &lt;code&gt;reject&lt;/code&gt; on it. Once a Promise is fulfilled or rejected, this state gets permanently associated with it. The state of a fulfilled Promise also includes the data that was passed to &lt;code&gt;resolve&lt;/code&gt;, just as the state of a rejected Promise also includes the data that was passed to &lt;code&gt;reject&lt;/code&gt;. In summary, we can say that a Promise executes only once and stores the result of its execution.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var promise = new Promise(function(resolve, reject) {
  $.ajax({
    url: &amp;quot;http://api.icndb.com/jokes/random&amp;quot;,
    success: function(result) {
      resolve(result[&amp;quot;value&amp;quot;][&amp;quot;joke&amp;quot;]);
    }
  });
});

promise.then(function(result) {
  console.log(result);
});

promise.then(function(result) {
  console.log(result);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can test whether a Promise only ever executes once by adding a second callback to the previous example. In this case, we see that only one AJAX request gets made and that the same joke gets printed to the console twice. This clearly shows that our Promise was only executed once.&lt;/p&gt;

&lt;h3 id=&#34;the-then-method-and-chaining:e45390df332d7d109b53a5ac1df46eec&#34;&gt;The &lt;code&gt;then&lt;/code&gt; method and chaining&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;then&lt;/code&gt; method takes two arguments: a mandatory success callback and an optional failure callback. These callbacks are called when the Promise is settled (i.e. either fulfilled or rejected). If the Promise was fulfilled, the success callback will be fired with the data you passed to &lt;code&gt;resolve&lt;/code&gt;. If the Promise was rejected, the failure callback will be called with the data you passed to &lt;code&gt;reject&lt;/code&gt;. We&amp;rsquo;ve already covered most of this in the previous section.&lt;/p&gt;

&lt;p&gt;The real magic with the &lt;code&gt;then&lt;/code&gt; method happens when you start chaining several of them together. This chaining allows you to express your logic in separate stages, each of which can be made responsible for transforming data passed on by the previous stage or for running additional asynchronous requests. The code below shows how data returned by the success callback of the first &lt;code&gt;then&lt;/code&gt; method becomes available to the success callback of the second &lt;code&gt;then&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var promise = new Promise(function(resolve, reject) {
  $.ajax({
    url: &amp;quot;http://api.icndb.com/jokes/random&amp;quot;,
    success: function(result) {
      resolve(result[&amp;quot;value&amp;quot;][&amp;quot;joke&amp;quot;]);
    }
  });
});

promise.then(function(result) {
  return result;
}).then(function(result) {
  console.log(result);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This chaining is possible because the &lt;code&gt;then&lt;/code&gt; method returns a new Promise object that will resolve to the return value of the callback. Or in other words, by calling &lt;code&gt;return result;&lt;/code&gt; we cause the creation of an anonymous Promise object that looks something like shown below. Notice that this particular anonymous Promise object will resolve immediately, as it does not make any asynchronous requests.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;new Promise(function(resolve, reject) {
  resolve(result);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we understand that the &lt;code&gt;then&lt;/code&gt; method always returns a Promise object, let&amp;rsquo;s take a look at what happens when we tell the callback of a &lt;code&gt;then&lt;/code&gt; method to explicitly return a Promise object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function getJokePromise() {
  return new Promise(function(resolve, reject) {
    $.ajax({
      url: &amp;quot;http://api.icndb.com/jokes/random&amp;quot;,
      success: function(result) {
        resolve(result[&amp;quot;value&amp;quot;][&amp;quot;joke&amp;quot;]);
      }
    });
  });
}

getJokePromise().then(function(result) {
  console.log(result);
  return getJokePromise();
}).then(function(result) {
  console.log(result);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, we end up sequentially executing two asynchronous requests. When the first Promise is resolved, the first joke is printed and a new Promise object is returned by the &lt;code&gt;then&lt;/code&gt; method. This new Promise object then has &lt;code&gt;then&lt;/code&gt; called on it. When the Promise succeeds, the &lt;code&gt;then&lt;/code&gt; success callback is triggered and the second joke is printed.&lt;/p&gt;

&lt;p&gt;The takeaway from all this is that calling &lt;code&gt;return&lt;/code&gt; in a &lt;code&gt;then&lt;/code&gt; callback will always result in returning a Promise object. It is this that allows for &lt;code&gt;then&lt;/code&gt; chaining!&lt;/p&gt;

&lt;h3 id=&#34;error-handling:e45390df332d7d109b53a5ac1df46eec&#34;&gt;Error handling&lt;/h3&gt;

&lt;p&gt;We mentioned in the previous section how the &lt;code&gt;then&lt;/code&gt; method can take an optional failure callback that gets triggered when &lt;code&gt;reject&lt;/code&gt; is called. It is customary to reject with an Error object as they capture a stack trace, thereby facilitating debugging.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var promise = new Promise(function(resolve, reject) {
  $.ajax({
    url: &amp;quot;http://random.url.com&amp;quot;,
    success: function(result) {
      resolve(result[&amp;quot;value&amp;quot;][&amp;quot;joke&amp;quot;]);
    },
    error: function(jqxhr, textStatus) {
      reject(Error(&amp;quot;The AJAX request failed.&amp;quot;));
    }
  });
});

promise.then(function(result) {
  console.log(result);
}, function(error) {
  console.log(error);
  console.log(error.stack);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Personally, I find this a bit hard to read. Luckily we can use the &lt;code&gt;catch&lt;/code&gt; method to make this look a bit nicer. There&amp;rsquo;s nothing special about the &lt;code&gt;catch&lt;/code&gt; method. In fact, it&amp;rsquo;s just sugar for &lt;code&gt;then(undefined, func)&lt;/code&gt;, but it definitely makes code easier to read.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var promise = new Promise(function(resolve, reject) {
  $.ajax({
    url: &amp;quot;http://random.url.com&amp;quot;,
    success: function(result) {
      resolve(result[&amp;quot;value&amp;quot;][&amp;quot;joke&amp;quot;]);
    },
    error: function(jqxhr, textStatus) {
      reject(Error(&amp;quot;The AJAX request failed.&amp;quot;));
    }
  });
});

promise.then(function(result) {
  console.log(result);
}).then(function(result) {
  console.log(&amp;quot;foo&amp;quot;); // gets skipped
}).then(function(result) {
  console.log(&amp;quot;bar&amp;quot;); // gets skipped
}).catch(function(error) {
  console.log(error);
  console.log(error.stack);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aside from illustrating improved readability, the above code showcases another aspect of the &lt;code&gt;reject&lt;/code&gt; method in that Promise rejections will cause your code to skip forward to the next &lt;code&gt;then&lt;/code&gt; method that has a rejection callback (or the next &lt;code&gt;catch&lt;/code&gt; method, since this is equivalent). It is this fallthrough behavior that causes this code to not print &amp;ldquo;foo&amp;rdquo; or &amp;ldquo;bar&amp;rdquo;!&lt;/p&gt;

&lt;p&gt;As a final point, it is useful to know that a Promise is implicitly rejected if an error is thrown in its constructor callback. This means it&amp;rsquo;s useful to do all your Promise related work inside the Promise constructor callback, so errors automatically become rejections.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var promise = new Promise(function(resolve, reject) {
  // JSON.parse throws an error if you feed it some
  // invalid JSON, so this implicitly rejects
  JSON.parse(&amp;quot;This ain&#39;t JSON&amp;quot;);
});

promise.then(function(result) {
  console.log(result);
}).catch(function(error) {
  console.log(error);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code will cause the Promise to be rejected and an error to be printed because it will fail to parse the invalid JSON string.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unwanted spot instance termination in multi-AZ ASG</title>
      <link>http://vaneyckt.io/posts/unwanted_spot_instance_termination_in_multi_az_asg/</link>
      <pubDate>Sat, 24 Jan 2015 19:17:53 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/unwanted_spot_instance_termination_in_multi_az_asg/</guid>
      <description>&lt;p&gt;An auto scaling group is an AWS abstraction that facilitates increasing or decreasing the number of EC2 instances within your application&amp;rsquo;s architecture. Spot instances are unused AWS servers that are auctioned off for little money. The combination of these two allows for large auto scaling groups at low costs. However, you can lose your spot instances at a moment&amp;rsquo;s notice as soon as someone out there wants to pay more than you do.&lt;/p&gt;

&lt;p&gt;Knowing all this, I recently found myself looking into why AWS was terminating several of our spot instances every day. We were bidding 20% over the average price, so it seemed unlikely that this was being caused by a monetary issue. Nevertheless, we kept noticing multiple spot instances disappearing on a daily basis.&lt;/p&gt;

&lt;p&gt;It took a while to get to the bottom of things, but it turned out that this particular problem was being caused by an unfortunate combination of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;our auto scaling group spanning multiple availability zones&lt;/li&gt;
&lt;li&gt;our scaling code making calls to &lt;code&gt;TerminateInstanceInAutoScalingGroup&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The step-by-step explanation of this issue was as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;our scaling code was asking AWS to put 10 instances in our auto scaling group&lt;/li&gt;
&lt;li&gt;AWS obliged and put 5 instances in availability zone A and another 5 in zone B&lt;/li&gt;
&lt;li&gt;some time later our scaling code would decide that 2 specific instances were no longer needed. A call would be made to &lt;code&gt;TerminateInstanceInAutoScalingGroup&lt;/code&gt; to have just these 2 specific instances terminated.&lt;/li&gt;
&lt;li&gt;if these 2 instances happened to be in the same availability zone, then one zone would now have 3 instances, while the other one would now have 5&lt;/li&gt;
&lt;li&gt;AWS would detect that both zones were no longer balanced and would initiate a rebalancing action. This rebalancing action would terminate one of the instances in the zone with 5 instances, and spin up another instance in the zone with 3 instances.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So while this action did indeed end up rebalancing the instances across the different availability zones, it also inadvertently ended up terminating a running instance.&lt;/p&gt;

&lt;p&gt;The relevant entry from the &lt;a href=&#34;http://awsdocs.s3.amazonaws.com/AutoScaling/latest/as-dg.pdf&#34;&gt;AWS Auto Scaling docs&lt;/a&gt; is shown below.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Instance Distribution and Balance across Multiple Zones&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Auto Scaling attempts to distribute instances evenly between the Availability Zones that are enabled for your Auto Scaling group. Auto Scaling attempts to launch new instances in the Availability Zone with the fewest instances. If the attempt fails, however, Auto Scaling will attempt to launch in other zones until it succeeds.&lt;/p&gt;

&lt;p&gt;Certain operations and conditions can cause your Auto Scaling group to become unbalanced. Auto Scaling compensates by creating a rebalancing activity under any of the following conditions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You issue a request to change the Availability Zones for your group.&lt;/li&gt;
&lt;li&gt;You call &lt;code&gt;TerminateInstanceInAutoScalingGroup&lt;/code&gt;, which causes the group to become unbalanced.&lt;/li&gt;
&lt;li&gt;An Availability Zone that previously had insufficient capacity recovers and has additional capacity available.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Auto Scaling always launches new instances before attempting to terminate old ones, so a rebalancing activity will not compromise the performance or availability of your application.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Multi-Zone Instance Counts when Approaching Capacity&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Because Auto Scaling always attempts to launch new instances before terminating old ones, being at or near the specified maximum capacity could impede or completely halt rebalancing activities. To avoid this problem, the system can temporarily exceed the specified maximum capacity of a group by a 10 percent margin during a rebalancing activity (or by a 1-instance margin, whichever is greater). The margin is extended only if the group is at or near maximum capacity and needs rebalancing, either as a result of user-requested rezoning or to compensate for zone availability issues. The extension lasts only as long as needed to rebalance the group—typically a few minutes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I&amp;rsquo;m not sure about the best way to deal with this behavior. In our case, we just restricted our auto scaling group to one availability zone. This was good enough for us as none of the work done by our spot instances is critical. Going through the &lt;a href=&#34;http://awsdocs.s3.amazonaws.com/AutoScaling/latest/as-dg.pdf&#34;&gt;docs&lt;/a&gt;, it seems one approach might be to disable the &lt;code&gt;AZRebalance&lt;/code&gt; process. However, I have not had the chance to try this, so I cannot guarantee a lack of unexpected side effects.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Creating an EC2 Instance in a VPC with the AWS CLI</title>
      <link>http://vaneyckt.io/posts/creating_an_ec2_instance_in_a_vpc_with_the_aws_cli/</link>
      <pubDate>Wed, 29 Oct 2014 17:36:12 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/creating_an_ec2_instance_in_a_vpc_with_the_aws_cli/</guid>
      <description>

&lt;p&gt;Setting up an EC2 instance on AWS used to be as straightforward as provisioning a machine and SSHing into it. However, this process has become a bit more complicated now that Amazon VPC has become the standard for managing machines in the cloud.&lt;/p&gt;

&lt;p&gt;So what exactly is a Virtual Private Cloud? Amazon defines a VPC as &amp;lsquo;a logically isolated section of the AWS Cloud&amp;rsquo;. Instances inside a VPC can by default only communicate with other instances in the same VPC and are therefore invisible to the rest of the internet. This means they will not accept SSH connections coming from your computer, nor will they respond to any http requests. In this article we&amp;rsquo;ll look into changing these default settings into something more befitting a general purpose server.&lt;/p&gt;

&lt;h3 id=&#34;setting-up-your-vpc:ed16f33dbf5018a09918ad8ef3c5f741&#34;&gt;Setting up your VPC&lt;/h3&gt;

&lt;p&gt;Start by installing the &lt;a href=&#34;http://aws.amazon.com/cli&#34;&gt;AWS Command Line Interface&lt;/a&gt; on your machine if you haven&amp;rsquo;t done so already. With this done, we can now create our VPC.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vpcId=`aws ec2 create-vpc --cidr-block 10.0.0.0/28 --query &#39;Vpc.VpcId&#39; --output text`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are several interesting things here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the &lt;code&gt;--cidr-block&lt;/code&gt; parameter specifies a /28 netmask that allows for 16 IP addresses. This is the smallest supported netmask.&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;create-vpc&lt;/code&gt; command returns a JSON string. We can filter out specific fields from this string by using the &lt;code&gt;--query&lt;/code&gt; and &lt;code&gt;--output&lt;/code&gt; parameters.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The next step is to overwrite the default VPC DNS settings. As mentioned earlier, instances launched inside a VPC are invisible to the rest of the internet by default. AWS therefore does not bother assigning them a public DNS name. Luckily this can be changed easily.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ aws ec2 modify-vpc-attribute --vpc-id $vpcId --enable-dns-support &amp;quot;{\&amp;quot;Value\&amp;quot;:true}&amp;quot;
$ aws ec2 modify-vpc-attribute --vpc-id $vpcId --enable-dns-hostnames &amp;quot;{\&amp;quot;Value\&amp;quot;:true}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;adding-an-internet-gateway:ed16f33dbf5018a09918ad8ef3c5f741&#34;&gt;Adding an Internet Gateway&lt;/h3&gt;

&lt;p&gt;Next we need to connect our VPC to the rest of the internet by attaching an internet gateway. Our VPC would be isolated from the internet without this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ internetGatewayId=`aws ec2 create-internet-gateway --query &#39;InternetGateway.InternetGatewayId&#39; --output text`
$ aws ec2 attach-internet-gateway --internet-gateway-id $internetGatewayId --vpc-id $vpcId
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;creating-a-subnet:ed16f33dbf5018a09918ad8ef3c5f741&#34;&gt;Creating a Subnet&lt;/h3&gt;

&lt;p&gt;A VPC can have multiple subnets. Since our use case only requires one, we can reuse the cidr-block specified during VPC creation so as to get a single subnet that spans the entire VPC address space.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ subnetId=`aws ec2 create-subnet --vpc-id $vpcId --cidr-block 10.0.0.0/28 --query &#39;Subnet.SubnetId&#39; --output text`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While this &lt;code&gt;--cidr-block&lt;/code&gt; parameter specifies a subnet that can contain 16 IP addresses (10.0.0.1 - 10.0.0.16), AWS will reserve 5 of those for private use. While this doesn&amp;rsquo;t really have an impact on our use case, it is still good to be aware of such things.&lt;/p&gt;

&lt;h3 id=&#34;configuring-the-route-table:ed16f33dbf5018a09918ad8ef3c5f741&#34;&gt;Configuring the Route Table&lt;/h3&gt;

&lt;p&gt;Each subnet needs to have a route table associated with it to specify the routing of its outbound traffic. By default every subnet inherits the default VPC route table which allows for intra-VPC communication only.&lt;/p&gt;

&lt;p&gt;Here we add a route table to our subnet so as to allow traffic not meant for an instance inside the VPC to be routed to the internet through the internet gateway we created earlier.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ routeTableId=`aws ec2 create-route-table --vpc-id $vpcId --query &#39;RouteTable.RouteTableId&#39; --output text`
$ aws ec2 associate-route-table --route-table-id $routeTableId --subnet-id $subnetId
$ aws ec2 create-route --route-table-id $routeTableId --destination-cidr-block 0.0.0.0/0 --gateway-id $internetGatewayId
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;adding-a-security-group:ed16f33dbf5018a09918ad8ef3c5f741&#34;&gt;Adding a Security Group&lt;/h3&gt;

&lt;p&gt;Before we can launch an instance, we first need to create a security group that specifies which ports should allow traffic. For now we&amp;rsquo;ll just allow anyone to try and make an SSH connection by opening port 22 to any IP address.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ securityGroupId=`aws ec2 create-security-group --group-name my-security-group --description &amp;quot;my-security-group&amp;quot; --vpc-id $vpcId --query &#39;GroupId&#39; --output text`
$ aws ec2 authorize-security-group-ingress --group-id $securityGroupId --protocol tcp --port 22 --cidr 0.0.0.0/0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;launching-your-instance:ed16f33dbf5018a09918ad8ef3c5f741&#34;&gt;Launching your Instance&lt;/h3&gt;

&lt;p&gt;All that&amp;rsquo;s left to do is to create an SSH key pair and then launch an instance secured by this. Let&amp;rsquo;s generate this key pair and store it locally with the correct permissions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ aws ec2 create-key-pair --key-name my-key --query &#39;KeyMaterial&#39; --output text &amp;gt; ~/.ssh/my-key.pem
$ chmod 400 ~/.ssh/my-key.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now launch a single t2.micro instance based on the public AWS Ubuntu image.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ instanceId=`aws ec2 run-instances --image-id ami-9eaa1cf6 --count 1 --instance-type t2.micro --key-name my-key --security-group-ids $securityGroupId --subnet-id $subnetId --associate-public-ip-address --query &#39;Instances[0].InstanceId&#39; --output text`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After a few minutes your instance should be up and running. You should now be able to obtain the url of your active instance and SSH into it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ instanceUrl=`aws ec2 describe-instances --instance-ids $instanceId --query &#39;Reservations[0].Instances[0].PublicDnsName&#39; --output text`
$ ssh -i ~/.ssh/my-key.pem ubuntu@$instanceUrl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s it. It&amp;rsquo;s really not all that hard. There&amp;rsquo;s just an awful lot of concepts that you need to get your head around which can make it a bit daunting at first. Be sure to check out the free &lt;a href=&#34;http://www.amazon.com/gp/product/B007S33NT2/ref=cm_cr_ryp_prd_ttl_sol_0&#34;&gt;Amazon Virtual Private Cloud User Guide&lt;/a&gt; if you want to learn more about VPCs.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Finding and deleting old tags in a Github repository</title>
      <link>http://vaneyckt.io/posts/finding_and_deleting_old_tags_in_a_github_repo/</link>
      <pubDate>Fri, 18 Jul 2014 19:32:12 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/finding_and_deleting_old_tags_in_a_github_repo/</guid>
      <description>

&lt;p&gt;It&amp;rsquo;s very easy for a Github repository to accumulate lots of tags over time. This onslaught of tags tends to be tolerated until it starts impacting git performance. It is at this point, when you have well in excess of tens of thousands of tags, that a call to action tends to be made. In this article, we&amp;rsquo;ll look at two approaches to rid yourself of these old tags.&lt;/p&gt;

&lt;h3 id=&#34;the-cut-off-tag-approach:257dca9811faca70d0b7c4cba16ee1c1&#34;&gt;The cut-off tag approach&lt;/h3&gt;

&lt;p&gt;This approach has us specify a cut-off tag. All tags that can trace their ancestry back to this cut-off tag will be allowed to remain. All others will get deleted. This is especially useful for when you have just merged a new feature, and now you want to delete all tags that were created before this merge. In this scenario, all you have to do is tag the merge commit and then use this as the cut-off tag.&lt;/p&gt;

&lt;p&gt;The sequence of commands below deletes all tags that do not have the release-5 tag as an ancestor. Most of these commands are pretty self-explanatory, except for the one in the middle. The remainder of this section will focus on explaining this command.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# fetch all tags from the remote
git fetch

# delete all tags on the remote that do not have the release-5 tag as an ancestor
comm -23 &amp;lt;(git tag | sort) &amp;lt;(git tag --contains release-5 | sort) | xargs git push --delete origin

# delete all local tags that are no longer present on the remote
git fetch --prune origin +refs/tags/*:refs/tags/*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;http://linux.die.net/man/1/comm&#34;&gt;comm command&lt;/a&gt; is used to &lt;a href=&#34;http://www.unixcl.com/2009/08/linux-comm-command-brief-tutorial.html&#34;&gt;compare two sorted files line by line&lt;/a&gt;. Luckily, we can avoid having to create any actual files by relying on process substitution instead.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;comm -23 &amp;lt;(command to act as file 1) &amp;lt;(command to act as file 2) | xargs git push --delete origin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;-23&lt;/code&gt; flag tells &lt;code&gt;comm&lt;/code&gt; to suppress any lines that are unique to file 2, as well as any lines that appear in both files. In other words, it causes &lt;code&gt;comm&lt;/code&gt; to return just those lines that only appear in file 1. Looking back at our sequence of commands above, it should be clear that this will cause us to obtain all tags that do not have the release-5 tag as an ancestor. Piping this output to &lt;code&gt;xargs git push --delete origin&lt;/code&gt; will then remove these tags from Github.&lt;/p&gt;

&lt;h3 id=&#34;the-cut-off-date-approach:257dca9811faca70d0b7c4cba16ee1c1&#34;&gt;The cut-off date approach&lt;/h3&gt;

&lt;p&gt;While the cut-off tag approach works great in a lot of scenarios, sometimes you just want to delete all tags that were created before a given cut-off date instead. Unfortunately, git doesn&amp;rsquo;t have any built-in functionality for accomplishing this. This is why we are going to make use of a Ruby script here.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# CUT_OFF_DATE needs to be of YYYY-MM-DD format
CUT_OFF_DATE = &amp;quot;2015-05-10&amp;quot;

def get_old_tags(cut_off_date)  
  `git log --tags --simplify-by-decoration --pretty=&amp;quot;format:%ai %d&amp;quot;`
  .split(&amp;quot;\n&amp;quot;)
  .each_with_object([]) do |line, old_tags|
    if line.include?(&amp;quot;tag: &amp;quot;)
      date = line[0..9]
      tags = line[28..-2].gsub(&amp;quot;,&amp;quot;, &amp;quot;&amp;quot;).concat(&amp;quot; &amp;quot;).scan(/tag: (.*?) /).flatten
      old_tags.concat(tags) if date &amp;lt; cut_off_date
    end
  end
end

# fetch all tags from the remote
`git fetch`

# delete all tags on the remote that were created before the CUT_OFF_DATE
get_old_tags(CUT_OFF_DATE).each_slice(100) do |batch|
  system(&amp;quot;git&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;--delete&amp;quot;, &amp;quot;origin&amp;quot;, *batch)
end

# delete all local tags that are no longer present on the remote
`git fetch --prune origin +refs/tags/*:refs/tags/*`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This Ruby script should be pretty straightforward. The &lt;code&gt;get_old_tags&lt;/code&gt; method might stand out a bit here. It can look pretty complex, but most of it is just string manipulation to get the date and tags of each line outputted by the &lt;code&gt;git log&lt;/code&gt; command, and storing old tags in the &lt;code&gt;old_tags&lt;/code&gt; array. Note how we invoke the &lt;code&gt;system&lt;/code&gt; method with an array of arguments for those calls that require input. This protects us against possible shell injection.&lt;/p&gt;

&lt;p&gt;Be careful, as running this exact script inside your repository will delete all tags created before 2015-05-10. Also, be sure to specify your cut-off date in YYYY-MM-DD format!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Adding a post-execution hook to the db:migrate task</title>
      <link>http://vaneyckt.io/posts/adding_a_post_execution_hook_to_the_db_migrate_task/</link>
      <pubDate>Mon, 09 Jun 2014 16:31:22 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/adding_a_post_execution_hook_to_the_db_migrate_task/</guid>
      <description>&lt;p&gt;A few days ago we discovered that our MySQL database&amp;rsquo;s default character set and collation had been changed to the wrong values. Worse yet, it looked like this change had happened many months ago; something which we had been completely unaware of until now! In order to make sure this didn&amp;rsquo;t happen again, we looked into adding a post-execution hook to the rails db:migrate task.&lt;/p&gt;

&lt;p&gt;Our first attempt is shown below. Here, we append a post-execution hook to the existing db:migrate task by creating a new db:migrate task. In rake, when a task is defined twice, the behavior of the new task gets appended to the behavior of the old task. So even though the code below may give the impression of overwriting the rails db:migrate task, we are actually just appending a call to the &lt;code&gt;post_execution_hook&lt;/code&gt; method to it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;namespace :db do
  def post_execution_hook
    puts &#39;This code gets run after the rails db:migrate task.&#39;
    puts &#39;However, it only runs if the db:migrate task does not throw an exception.&#39;
  end

  task :migrate do
    post_execution_hook
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, the above example only runs the appended code if the original db:migrate task does not throw any exceptions. Luckily we can do better than that by taking a slightly different approach. Rather than appending code, we are going to have a go at prepending it instead.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;namespace :db do
  def post_execution_hook
    puts &#39;This code gets run after the rails db:migrate task.&#39;
    puts &#39;It will ALWAYS run.&#39;
  end

  task :attach_hook do
    at_exit { post_execution_hook }
  end
end

Rake::Task[&#39;db:migrate&#39;].enhance([&#39;db:attach_hook&#39;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we make use of the &lt;a href=&#34;http://ruby-doc.org/stdlib-2.0.0/libdoc/rake/rdoc/Rake/Task.html#method-i-enhance&#34;&gt;enhance method&lt;/a&gt; to add db:attach_hook as a prerequisite task to db:migrate. This means that calling db:migrate will now cause the db:attach_hook task to get executed before db:migrate gets run. The db:attach_hook task creates an &lt;code&gt;at_exit&lt;/code&gt; hook that will trigger our post-execution code upon exit of the db:migrate task. Hence, our post-execution hook will now get called even when db:migrate raises an exception!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Safer bash scripts with &#39;set -euxo pipefail&#39;</title>
      <link>http://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/</link>
      <pubDate>Wed, 14 May 2014 20:14:48 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/</guid>
      <description>

&lt;p&gt;Often times developers go about writing bash scripts the same as writing code in a higher-level language. This is a big mistake as higher-level languages offer safeguards that are not present in bash scripts by default. For example, a Ruby script will throw an error when trying to read from an uninitialized variable, whereas a bash script won&amp;rsquo;t. In this article, we&amp;rsquo;ll look at how we can improve on this.&lt;/p&gt;

&lt;p&gt;The bash shell comes with several builtin commands for modifying the behavior of the shell itself. We are particularly interested in the &lt;a href=&#34;https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html&#34;&gt;set builtin&lt;/a&gt;, as this command has several options that will help us write safer scripts. I hope to convince you that it&amp;rsquo;s a really good idea to add &lt;code&gt;set -euxo pipefail&lt;/code&gt; to the beginning of all your future bash scripts.&lt;/p&gt;

&lt;h3 id=&#34;set-e:d0406b09675b080255aad6f1a20a9332&#34;&gt;set -e&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;-e&lt;/code&gt; option will cause a bash script to exit immediately when a command fails. This is generally a vast improvement upon the default behavior where the script just ignores the failing command and continues with the next line. This option is also smart enough to not react on failing commands that are part of conditional statements. Moreover, you can append a command with &lt;code&gt;|| true&lt;/code&gt; for those rare cases where you don&amp;rsquo;t want a failing command to trigger an immediate exit.&lt;/p&gt;

&lt;h4 id=&#34;before:d0406b09675b080255aad6f1a20a9332&#34;&gt;Before&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

# &#39;foo&#39; is a non-existing command
foo
echo &amp;quot;bar&amp;quot;

# output
# ------
# line 4: foo: command not found
# bar
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;after:d0406b09675b080255aad6f1a20a9332&#34;&gt;After&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
set -e

# &#39;foo&#39; is a non-existing command
foo
echo &amp;quot;bar&amp;quot;

# output
# ------
# line 5: foo: command not found
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;prevent-immediate-exit:d0406b09675b080255aad6f1a20a9332&#34;&gt;Prevent immediate exit&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
set -e

# &#39;foo&#39; is a non-existing command
foo || true
echo &amp;quot;bar&amp;quot;

# output
# ------
# line 5: foo: command not found
# bar
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;set-o-pipefail:d0406b09675b080255aad6f1a20a9332&#34;&gt;set -o pipefail&lt;/h3&gt;

&lt;p&gt;The bash shell normally only looks at the exit code of the last command of a pipeline. This behavior is not ideal as it causes the &lt;code&gt;-e&lt;/code&gt; option to only be able to act on the exit code of a pipeline&amp;rsquo;s last command. This is where &lt;code&gt;-o pipefail&lt;/code&gt; comes in. This particular option sets the exit code of a pipeline to that of the rightmost command to exit with a non-zero status, or zero if all commands of the pipeline exit successfully.&lt;/p&gt;

&lt;h4 id=&#34;before-1:d0406b09675b080255aad6f1a20a9332&#34;&gt;Before&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
set -e

# &#39;foo&#39; is a non-existing command
foo | echo &amp;quot;a&amp;quot;
echo &amp;quot;bar&amp;quot;

# output
# ------
# a
# line 5: foo: command not found
# bar
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;after-1:d0406b09675b080255aad6f1a20a9332&#34;&gt;After&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
set -eo pipefail

# &#39;foo&#39; is a non-existing command
foo | echo &amp;quot;a&amp;quot;
echo &amp;quot;bar&amp;quot;

# output
# ------
# a
# line 5: foo: command not found
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;set-u:d0406b09675b080255aad6f1a20a9332&#34;&gt;set -u&lt;/h3&gt;

&lt;p&gt;This option causes the bash shell to treat unset variables as an error and exit immediately. This brings us much closer to the behavior of higher-level languages.&lt;/p&gt;

&lt;h4 id=&#34;before-2:d0406b09675b080255aad6f1a20a9332&#34;&gt;Before&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
set -eo pipefail

echo $a
echo &amp;quot;bar&amp;quot;

# output
# ------
#
# bar
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;after-2:d0406b09675b080255aad6f1a20a9332&#34;&gt;After&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
set -euo pipefail

echo $a
echo &amp;quot;bar&amp;quot;

# output
# ------
# line 5: a: unbound variable
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;set-x:d0406b09675b080255aad6f1a20a9332&#34;&gt;set -x&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;-x&lt;/code&gt; option causes bash to print each command before executing it. This can be of great help when you have to try and debug a bash script failure through its logs. Note that arguments get expanded before a command gets printed. This causes our logs to display the actual argument values at the time of execution!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
set -euxo pipefail

a=5
echo $a
echo &amp;quot;bar&amp;quot;

# output
# ------
# + a=5
# + echo 5
# 5
# + echo bar
# bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s it. I hope this post showed you why using &lt;code&gt;set -euxo pipefail&lt;/code&gt; is such a good idea. If you have any other options you want to suggest, then please let me know and I&amp;rsquo;ll be happy to add them to this list.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Programmatically rotating the Android screen</title>
      <link>http://vaneyckt.io/posts/programmatically_rotating_the_android_screen/</link>
      <pubDate>Thu, 20 Mar 2014 20:08:17 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/programmatically_rotating_the_android_screen/</guid>
      <description>&lt;p&gt;A lot of digital ink has been spilled on this subject, so I figured it might be worth to briefly talk about this. You can either change the orientation through ADB or through an app. While the ADB approach is the easiest, it might not work on all devices or on all Android versions. For example, the &lt;code&gt;dumpsys&lt;/code&gt; output of a Kindle Fire is different than that of a Samsung Galaxy S4, so you might need to tweak the grepping of the output.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# get current orientation
adb shell dumpsys input | grep SurfaceOrientation | awk &#39;{print $2}&#39;

# change orientaton to portait
adb shell content insert --uri content://settings/system --bind name:s:accelerometer_rotation --bind value:i:0
adb shell content insert --uri content://settings/system --bind name:s:user_rotation --bind value:i:0

# change orientation to landscape
adb shell content insert --uri content://settings/system --bind name:s:accelerometer_rotation --bind value:i:0
adb shell content insert --uri content://settings/system --bind name:s:user_rotation --bind value:i:1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don’t want to use ADB and prefer to change the orientation through an Android app instead, then you can just use these commands.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// get current orientation
final int orientation = myActivity.getResources().getConfiguration().orientation;

// change orientation to portrait
myActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);

// change orientation to landscape
myActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Programmatically creating Android touch events</title>
      <link>http://vaneyckt.io/posts/programmatically_creating_android_touch_events/</link>
      <pubDate>Tue, 04 Mar 2014 20:40:56 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/programmatically_creating_android_touch_events/</guid>
      <description>&lt;p&gt;Recent versions of Android have the &lt;code&gt;adb shell input touch&lt;/code&gt; functionality to simulate touch events on an Android device or simulator. However, older Android versions (like 2.3) do not support this command. Luckily it is possible to recreate this functionality by running &lt;code&gt;adb shell getevent&lt;/code&gt; to capture events as they are being generated. These events can then later be replayed using the &lt;code&gt;adb shell sendevent&lt;/code&gt; command.&lt;/p&gt;

&lt;p&gt;Running &lt;code&gt;adb shell getevent&lt;/code&gt; when touching the screen might get you something like shown below. Notice how the output is in hexadecimal.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/dev/input/event7: 0001 014a 00000001
/dev/input/event7: 0003 003a 00000001
/dev/input/event7: 0003 0035 000001ce
/dev/input/event7: 0003 0036 00000382
/dev/input/event7: 0000 0002 00000000
/dev/input/event7: 0000 0000 00000000
/dev/input/event7: 0001 014a 00000000
/dev/input/event7: 0003 003a 00000000
/dev/input/event7: 0003 0035 000001ce
/dev/input/event7: 0003 0036 00000382
/dev/input/event7: 0000 0002 00000000
/dev/input/event7: 0000 0000 00000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, the &lt;code&gt;adb shell sendevent&lt;/code&gt; command expect all of its input to be in decimal. So if we wanted to replay the above events, we&amp;rsquo;d need to do something like shown below. Note that 462 and 898 are the x and y coordinates of this particular touch event.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;adb shell sendevent /dev/input/event7: 1 330 1
adb shell sendevent /dev/input/event7: 3 58 1
adb shell sendevent /dev/input/event7: 3 53 462
adb shell sendevent /dev/input/event7: 3 54 898
adb shell sendevent /dev/input/event7: 0 2 0
adb shell sendevent /dev/input/event7: 0 0 0
adb shell sendevent /dev/input/event7: 1 330 0
adb shell sendevent /dev/input/event7: 3 58 0
adb shell sendevent /dev/input/event7: 3 53 462
adb shell sendevent /dev/input/event7: 3 54 898
adb shell sendevent /dev/input/event7: 0 2 0
adb shell sendevent /dev/input/event7: 0 0 0
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Some lesser known Github API functionality</title>
      <link>http://vaneyckt.io/posts/some_lesser_known_github_api_functionality-conflict-1/</link>
      <pubDate>Sat, 08 Feb 2014 18:05:12 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/some_lesser_known_github_api_functionality-conflict-1/</guid>
      <description>

&lt;p&gt;One of our automation tools occasionally needs to interact with our Github repositories. Unfortunately, the current implementation of this tool leaves something to be desired as it requires cloning these repositories to local disk. Changes against these local repositories are then made on local branches, after which these branches get pushed to Github.&lt;/p&gt;

&lt;p&gt;However, in order to save on disk space this tool will only ever create a single local copy of each repository. This makes it unsafe to run multiple instances of this tool as multiple instances simultaneously executing sequences of git commands against the same local repositories might lead to these commands inadvertently getting interpolated, thereby leaving the local repositories in an undefined state.&lt;/p&gt;

&lt;p&gt;The solution to this complexity was to completely remove the need for local repositories and instead aim to have everything done through the wonderful Github API. This article is a reminder to myself about some API functionality that I found while looking into this.&lt;/p&gt;

&lt;h3 id=&#34;checking-if-a-branch-contains-a-commit:2812339c011ecef2e0f6dd8f922aaa4f&#34;&gt;Checking if a branch contains a commit&lt;/h3&gt;

&lt;p&gt;While the Github API does not have an explicit call to check whether a given commit is included in a branch, we can nevertheless use the &lt;a href=&#34;https://developer.github.com/v3/repos/commits/#compare-two-commits&#34;&gt;compare call&lt;/a&gt; for just this purpose. This call takes two commits as input and returns a large JSON response of comparison data. We can use the &lt;code&gt;status&lt;/code&gt; field of the response to ascertain if a given commit is behind or identical to the HEAD commit of a branch. If so, then the branch contains that commit.&lt;/p&gt;

&lt;p&gt;We can use the &lt;a href=&#34;https://github.com/octokit/octokit.rb&#34;&gt;Ruby octokit gem&lt;/a&gt; to implement this as follows.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;octokit&#39;

class GithubClient &amp;lt; Octokit::Client
  def branch_contains_sha?(repo, branch, sha)
    [&#39;behind&#39;, &#39;identical&#39;].include?(compare(repo, branch, sha).status)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;creating-a-remote-branch-from-a-remote-commit:2812339c011ecef2e0f6dd8f922aaa4f&#34;&gt;Creating a remote branch from a remote commit&lt;/h3&gt;

&lt;p&gt;Sometimes you&amp;rsquo;ll want to create a remote branch by branching from a remote commit. We can use the &lt;a href=&#34;https://developer.github.com/v3/git/refs/#create-a-reference&#34;&gt;create_reference call&lt;/a&gt; to accomplish this. Note that the &lt;code&gt;ref&lt;/code&gt; parameter of this call needs to be set to &lt;code&gt;refs/heads/#{branch}&lt;/code&gt; when creating a remote branch.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;octokit&#39;

class GithubClient &amp;lt; Octokit::Client
  def create_branch_from_sha(repo, branch, sha)
    # create_ref internally transforms &amp;quot;heads/#{branch}&amp;quot; into &amp;quot;refs/heads/#{branch}&amp;quot;
    # as mentioned above, this is required by the Github API
    create_ref(repo, &amp;quot;heads/#{branch}&amp;quot;, sha)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;setting-the-head-of-a-remote-branch-to-a-specific-remote-commit:2812339c011ecef2e0f6dd8f922aaa4f&#34;&gt;Setting the HEAD of a remote branch to a specific remote commit&lt;/h3&gt;

&lt;p&gt;You can even forcefully set the HEAD of a remote branch to a specific remote commit by using the &lt;a href=&#34;https://developer.github.com/v3/git/refs/#update-a-reference&#34;&gt;update_reference call&lt;/a&gt;. As mentioned earlier, the &lt;code&gt;ref&lt;/code&gt; parameter needs to be set to &lt;code&gt;refs/heads/#{branch}&lt;/code&gt;. Be careful when using this functionality though as it essentially allows you to overwrite the history of a remote branch!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;octokit&#39;

class GithubClient &amp;lt; Octokit::Client
  def update_branch_to_sha(repo, branch, sha, force = true)
    # update_ref internally transforms &amp;quot;heads/#{branch}&amp;quot; into &amp;quot;refs/heads/#{branch}&amp;quot;
    # as mentioned earlier, this is required by the Github API
    update_ref(repo, &amp;quot;heads/#{branch}&amp;quot;, sha, force)
  end
end
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>The amazing bitwise XOR operator</title>
      <link>http://vaneyckt.io/posts/the_amazing_bitwise_xor_operator/</link>
      <pubDate>Sun, 12 Jan 2014 19:35:25 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/the_amazing_bitwise_xor_operator/</guid>
      <description>

&lt;p&gt;One of my colleagues recently mentioned this interview question to me.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Imagine there is an array which contains 2n+1 elements, n of which have exactly one duplicate. Can you find the one unique element in this array?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This seemed simple enough and I quickly came up with the Ruby solution below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; array = [3, 5, 4, 5, 3]
# =&amp;gt; [3, 5, 4, 5, 3]
&amp;gt; count = array.each_with_object(Hash.new(0)) { |number, hash| hash[number] += 1 }
# =&amp;gt; {3=&amp;gt;2, 5=&amp;gt;2, 4=&amp;gt;1}
&amp;gt; count.key(1)
# =&amp;gt; 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I thought that would be the end of it, but instead I was asked if I could see a way to solve the problem in a significantly more performant way using the XOR operator.&lt;/p&gt;

&lt;h3 id=&#34;xor-characteristics:3b1479834de8b2716c6d36848e7cf887&#34;&gt;XOR characteristics&lt;/h3&gt;

&lt;p&gt;In order to solve this problem with the XOR operator, we first need to understand some of its characteristics. This operator obeys the following rules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;commutativity: &lt;code&gt;A^B=B^A&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;associativity: &lt;code&gt;(A^B)^C=A^(B^C)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;the identity element is 0: &lt;code&gt;A^0=A&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;each element is its own inverse: &lt;code&gt;A^A=0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now imagine an array with the elements &lt;code&gt;[3, 5, 4, 5, 3]&lt;/code&gt;. Using the above rules, we can show that XORing all these elements will leave us with the array&amp;rsquo;s unique element.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;accum = 3 ^ 5 ^ 4 ^ 5 ^ 3
accum = 0 ^ 3 ^ 5 ^ 4 ^ 5 ^ 3    # 0 is the identity element
accum = 0 ^ 3 ^ 3 ^ 4 ^ 5 ^ 5    # commutativity and associativity rules
accum = 0 ^ 0 ^ 4 ^ 0            # A^A = 0
accum = 4                        # 0 is the identity element
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Putting this approach in code would give us something like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; array = [3, 5, 4, 5, 3]
# =&amp;gt; [3, 5, 4, 5, 3]
&amp;gt; accum = 0
# =&amp;gt; 0
&amp;gt; array.each { |number| accum = accum ^ number }
# =&amp;gt; [3, 5, 4, 5, 3]
&amp;gt; accum
# =&amp;gt; 4
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;benchmarks:3b1479834de8b2716c6d36848e7cf887&#34;&gt;Benchmarks&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s use Ruby&amp;rsquo;s &lt;code&gt;Benchmark&lt;/code&gt; module to do a comparison of both approaches.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;benchmark&#39;

array = [-1]
1000000.times do |t|
  array &amp;lt;&amp;lt; t
  array &amp;lt;&amp;lt; t
end

Benchmark.measure do
  count = array.each_with_object(Hash.new(0)) { |number, hash| hash[number] += 1 }
  count.key(1)
end
# =&amp;gt; #&amp;lt;Benchmark::Tms:0x007f83fa0279e0 @label=&amp;quot;&amp;quot;, @real=0.83534, @cstime=0.0, @cutime=0.0, @stime=0.010000000000000009, @utime=0.8300000000000005, @total=0.8400000000000005&amp;gt;

Benchmark.measure do
  accum = 0
  array.each { |number| accum = accum ^ number }
  accum
end
# =&amp;gt; #&amp;lt;Benchmark::Tms:0x007f83fa240ba0 @label=&amp;quot;&amp;quot;, @real=0.136726, @cstime=0.0, @cutime=0.0, @stime=0.0, @utime=0.13999999999999968, @total=0.13999999999999968&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So there you have it. Given an array that contains two million elements, the XOR operator approach turns out to be more than 6 times faster than utilizing a hashmap. That&amp;rsquo;s quite a nice performance improvement!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A visual explanation of SQL joins</title>
      <link>http://vaneyckt.io/posts/a_visual_explanation_of_sql_joins/</link>
      <pubDate>Sun, 17 Nov 2013 20:22:17 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/a_visual_explanation_of_sql_joins/</guid>
      <description>&lt;p&gt;I admit that I find myself going to &lt;a href=&#34;http://blog.codinghorror.com/a-visual-explanation-of-sql-joins/&#34;&gt;this article&lt;/a&gt; every time I need to write some joins. Hopefully putting it here will save me from always having to google it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Check the order of your rescue_from handlers!</title>
      <link>http://vaneyckt.io/posts/check_the_order_of_your_rescue_from_handlers/</link>
      <pubDate>Mon, 11 Nov 2013 21:34:16 +0000</pubDate>
      
      <guid>http://vaneyckt.io/posts/check_the_order_of_your_rescue_from_handlers/</guid>
      <description>&lt;p&gt;Our &lt;code&gt;rescue_from&lt;/code&gt; handlers used to be defined like shown below. This might look okay to you. At first glance everything looks fine, right?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class WidgetsController &amp;lt; ActionController::Base
  rescue_from ActionController::RoutingError, :with =&amp;gt; :render_404
  rescue_from Exception,                      :with =&amp;gt; :render_500
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Turns out it&amp;rsquo;s not okay at all. Handlers are searched &lt;a href=&#34;http://apidock.com/rails/ActiveSupport/Rescuable/ClassMethods/rescue_from&#34;&gt;from bottom to top&lt;/a&gt;. This means that they should always be defined in order of most generic to most specific. Or in other words, the above code is exactly the wrong thing to do. Instead, we need to write our handlers like shown here.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class WidgetsController &amp;lt; ActionController::Base
  rescue_from Exception,                      :with =&amp;gt; :render_500
  rescue_from ActionController::RoutingError, :with =&amp;gt; :render_404
end
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>